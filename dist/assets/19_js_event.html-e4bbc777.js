import{_ as e,o as n,c as l,f as a}from"./app-f4e03468.js";const i={},o=a(`<h1 id="dom-事件" tabindex="-1"><a class="header-anchor" href="#dom-事件" aria-hidden="true">#</a> DOM 事件</h1><h2 id="事件的简介" tabindex="-1"><a class="header-anchor" href="#事件的简介" aria-hidden="true">#</a> 事件的简介</h2><p>用户和浏览器之间的交互行为。点击某个元素、鼠标移动，关闭弹窗等等。</p><p>JavaScript 是以事件驱动为核心的语言。js 和 html 之间的交互是通过事件实现的。</p><p>我们可以在事件对应的属性中，设置一些 JS 代码，当事件被触发时，这些代码将会执行。</p><p>事件的三要素：事件源、事件、事件驱动程序</p><ul><li>网页上弹出一个广告，我点击右上角的 X，广告就关闭了。这件事情里，事件源是：X。事件是：onclick。事件驱动程序是：广告关闭了。</li><li>谁引发的后续事件，谁就是事件源。</li></ul><ol><li>获取事件源：\`document.getElementById(&quot;box&quot;);</li><li>绑定事件：<code>事件源.事件 = function(){事件的驱动程序}</code><ul><li>box.onclick = function(){alert(&quot;box 被点击&quot;)};</li></ul></li><li>书写事件驱动程序：关于 DOM 的操作</li></ol><h2 id="事件对象-event" tabindex="-1"><a class="header-anchor" href="#事件对象-event" aria-hidden="true">#</a> 事件对象 event</h2><p>当事件的响应函数被触发时，会产生一个事件对象 event。浏览器每次都会将这个事件 event 作为实参传递给之前的响应函数。</p><p>这个对象中，包含了与当前事件相关的一切信息，比如鼠标的坐标、键盘的哪个按键被按下、鼠标滚轮滚动的方向。</p><ul><li>所有浏览器都支持 event 对象</li><li>普通浏览器写法：<code>event</code></li><li>IE8 及以下写法：<code>window.event</code></li><li>兼容的写法：<code>event = event || window.event;</code></li></ul><p>事件对象的常用属性：</p><ul><li><code>timeStamp</code>返回事件生成的日期和事件</li><li><code>bubbles</code>返回布尔值，指示事件是否时冒泡事件类型</li><li><code>button</code>返回事件被触发时，哪个鼠标按钮被点击</li><li><code>target</code>该事件被传送到的对象</li><li><code>type</code>事件的类型</li><li><code>pageX</code>和<code>pageY</code>光标在该网页的距离</li><li><code>clientX</code>和<code>clientY</code>光标在可视区域的距离</li><li><code>screenX</code>和<code>screenY</code>光标相对于浏览器的距离</li></ul><h2 id="事件的冒泡-bubble" tabindex="-1"><a class="header-anchor" href="#事件的冒泡-bubble" aria-hidden="true">#</a> 事件的冒泡 Bubble</h2><ul><li>指事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发。</li><li><code>div -&gt; body -&gt; html -&gt; document -&gt; window</code></li><li>从开发的角度，冒泡多数情况是有用的。</li><li><code>event.cancelBubble = true;</code>可以取消冒泡</li></ul><h2 id="事件的委派-委托" tabindex="-1"><a class="header-anchor" href="#事件的委派-委托" aria-hidden="true">#</a> 事件的委派（委托）</h2><ul><li>将事件统一绑定给元素的共同祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，通过祖先元素的响应函数来处理事件。</li><li>事件的委派利用了冒泡的原理，通过委派减少事件的绑定次数，提高程序的性能。</li><li>如果触发事件的对象是我们期望的元素，则执行,否则不执行。</li><li>event 中的 target 表示触发事件的对象。</li></ul><h2 id="事件的绑定-注册" tabindex="-1"><a class="header-anchor" href="#事件的绑定-注册" aria-hidden="true">#</a> 事件的绑定（注册）</h2><p>绑定（注册）事件的两种方式：</p><ul><li><p><code>onclick</code></p><ul><li><code>element.onclick = function(){}</code></li><li><code>DOM对象.事件 = 函数</code>的这种绑定事件的方式，一个元素的一个事件只能绑定一个响应函数。绑定多个时，后者会覆盖前者。</li></ul></li><li><p><code>addEventListener</code></p><ul><li>\`element.addEventListener(&quot;click&quot;,function(){},false);</li><li>需要 3 个参数(IE8 及以下不支持)</li><li>1：事件的字符串（不要 on）</li><li>2：回调函数，当事件触发时，该函数会被执行</li><li>3：true 表示捕获阶段触发，false 表示冒泡阶段触发（默认），如果不写，就是默认值。</li></ul></li><li><p><code>attachEvent</code></p><ul><li>element.attachEvent(&quot;onclick&quot;,function(){});</li><li>需要两个参数（IE8 及以下版本浏览器）</li><li>1 事件的字符串（要 on）</li><li>2 回调函数：当事件触发时，该函数会被执行</li><li>注意：执行顺序是，后绑定的先执行。</li><li>attachEvent()中的 this，是 window</li></ul></li></ul><h2 id="事件的传播" tabindex="-1"><a class="header-anchor" href="#事件的传播" aria-hidden="true">#</a> 事件的传播</h2><p>事件的传播有 3 个阶段：事件捕获、冒泡、目标。</p><ul><li>事件捕获阶段：事件从祖先元素往子元素查找（DOM 树）结构，直到捕获到事件目标 target。在这个过程中，默认情况下，事件相应的监听函数是不会被触发的。 <ul><li>捕获顺序<code>window-&gt;document-&gt;html-&gt;body-&gt;父元素、子元素、目标元素</code></li></ul></li><li>事件目标：当到达目标元素之后，执行目标元素该事件相应的处理函数</li><li>事件的冒泡阶段：事件从事件目标 target 开始，从子元素依次触发祖先元素。 <ul><li>冒泡顺序<code>div-&gt;body-&gt;html-&gt;document</code></li></ul></li></ul><p>重点：</p><ul><li>第一个接收到事件的对象是 window</li><li>js 中设计到 DOM 对象时，有两个对象最常用：window、document。它们两个是最先获取到事件的。</li></ul><h2 id="鼠标事件" tabindex="-1"><a class="header-anchor" href="#鼠标事件" aria-hidden="true">#</a> 鼠标事件</h2><p>鼠标拖拽事件：</p><ul><li><code>onmousedown</code>当鼠标按下时，开始拖拽、 <ul><li>获取<code>e.pageX - box1.offsetLeft</code></li><li>获取<code>e.pageY - box1.offsetTop</code></li></ul></li><li><code>onmousemove</code>当鼠标移动时，元素跟随鼠标移动 <ul><li><code>box1.style.left = e.pageX - ox + &quot;px&quot;;</code></li><li><code>box1.style.top = e.pageY - oy + &quot;px&quot;;</code></li></ul></li><li><code>onmouseup</code>当鼠标松开时，元素固定在当前位置 <ul><li><code>document.onmousemove = null;</code></li></ul></li></ul><p>鼠标滚轮事件：</p><ul><li><code>onmousewheel</code>鼠标滚动的事件，会在滚轮滚动时触发，但是火狐不支持该属性。</li><li><code>DOMMouseScroll</code>在火狐中使用<code>DOMMouseScroll</code>。注意该事件需要通过 addEventListener()函数来绑定。</li><li>一般情况下，监听 wheelDelta 的正负值，就可以确定鼠标滚轮的滚动方向。</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>
  <span class="token string">&quot;mousewheel&quot;</span><span class="token punctuation">,</span>
  <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>wheelDelta<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//向下滚&lt;0</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token boolean">false</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>火狐浏览器鼠标滚轮的信息保存在 detail 属性里面</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>
  <span class="token string">&quot;DOMMouseScroll&quot;</span><span class="token punctuation">,</span>
  <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>detail<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//向下滚&gt;0</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token boolean">false</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>通过 addEventLister()方法绑定的响应函数，取消默认行为不能使用<code>return false</code>，而是使用<code>event.preventDefault();</code></li></ul><h2 id="键盘事件" tabindex="-1"><a class="header-anchor" href="#键盘事件" aria-hidden="true">#</a> 键盘事件</h2><ul><li><code>onkeydown</code>按键被按下</li><li><code>onkeyup</code>按键被松开</li><li>键盘事件一般都会绑定给一些可以获取焦点的对象或者 document</li><li>如果一直按住某个键不松手，那么<code>onkeydown</code>事件会一直触发。</li><li>当 onkeydown 连续触发时，第一次和第二次之间会间隔稍微长一点，后续的间隔会非常快。这种设计是为了防止误操作的发生。</li></ul><p>判断键盘哪个键被按下：</p><ul><li><code>altKey</code>返回当事件被触发时，&quot;ALT&quot; 是否被按下。</li><li><code>shiftKey</code>返回当事件被触发时，&quot;SHIFT&quot; 键是否被按下</li><li><code>ctrlKey</code>返回当事件被触发时，&quot;CTRL&quot; 键是否被按下</li><li>如果按下则返回 true，否则返回 false。</li></ul><p>通过 event 事件对象的 key 来获取按键。（keycode 已弃用）</p><ul><li><code>event.key</code>直接返回按键的字符串</li></ul><p>在文本框中输入内容，属于 onkeydown 中默认行为，如果使用<code>return false</code>，则文本框不能输入内容。</p>`,42),t=[o];function s(c,d){return n(),l("div",null,t)}const p=e(i,[["render",s],["__file","19_js_event.html.vue"]]);export{p as default};
