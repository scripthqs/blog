import{_ as e,o as l,c as i,f as t}from"./app-10c4e004.js";const a={},n=t('<h1 id="react-组件化开发" tabindex="-1"><a class="header-anchor" href="#react-组件化开发" aria-hidden="true">#</a> React 组件化开发</h1><p>React 的组件相对于 Vue 更加灵活，可以按照不同的方式分成很多类组件</p><ul><li>根据组件的定义方式，可以分为：函数组件(Function Component)和类组件(Class Component)</li><li>根据组件内部是否有状态需要维护，可以分为：无状态组件(Stateless Component)和有状态组件(Stateful Component)</li><li>根据组件的不同职责，可以分为：展示型组件(Presentation Component)和容器型组件(Container Component)</li></ul><p>不同组件的区别：</p><ul><li>函数组件、无状态组件、展示型组件主要关注 UI 的展示</li><li>类组件、有状态组件、容器型组件主要关注数据逻辑</li></ul><h2 id="类组件" tabindex="-1"><a class="header-anchor" href="#类组件" aria-hidden="true">#</a> 类组件</h2><p>类组件的定义要求：</p><ul><li>组件的名称是大写字符开头(包括类组件和函数组件)</li><li>类组件需要继承自 React.Component</li><li>类组件必须实现 render 函数</li></ul><p>在 ES6 之前，可以通过 create-react-class 模块来定义类组件，ES6 后官网建议使用 ES6 的 class 类</p><ul><li>constructor 是可选的，通常在 constructor 中初始化一些数据</li><li>this.state 中维护的是组件内部的数据</li><li>render()方法是 class 组件唯一必须实现的方法</li></ul><h2 id="render-函数的返回值" tabindex="-1"><a class="header-anchor" href="#render-函数的返回值" aria-hidden="true">#</a> render 函数的返回值</h2><p>当 render 被调用时，它会检查 this.props 和 this.state 的变化并返回一下类型之一：</p><ol><li>React 元素 <ul><li>jsx：通过 jsx 编写的代码就会编译成 React.createElement，所以 jsx 是 React 元素</li><li><code>&lt;div/&gt;</code>会被 React 渲染成 DOM 节点，<code>&lt;MyComponent/&gt;</code>会被 React 渲染成自定义组件</li></ul></li><li>数组或 fragments <ul><li>可以让 render 方法返回多个元素</li></ul></li><li>Portals <ul><li>可以渲染子节点到不同的 DOM 子树中</li></ul></li><li>字符串或数值类型 <ul><li>在 DOM 中被渲染成文本节点</li></ul></li><li>布尔类型或 null <ul><li>什么都不渲染</li></ul></li></ol><h2 id="函数组件" tabindex="-1"><a class="header-anchor" href="#函数组件" aria-hidden="true">#</a> 函数组件</h2><p>函数组件使用 function 来定义函数，返回值和类组件 render 函数返回一致，函数组件有自己的特点</p><ul><li>没有生命周期，也会被更新并挂载，但是没有生命周期函数</li><li>this 关键字不能指向组件实例(没有组件实例)</li><li>没有内部状态 state，有也无法维护</li></ul><p>之前函数组件只能做展示，不过有了 hooks 后就不一样了</p>',17),r=[n];function o(c,s){return l(),i("div",null,r)}const u=e(a,[["render",o],["__file","04_react_component.html.vue"]]);export{u as default};
