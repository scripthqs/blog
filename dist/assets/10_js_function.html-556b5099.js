import{_ as n,o as a,c as s,f as e}from"./app-c6441670.js";const i={},t=e(`<h1 id="函数基础" tabindex="-1"><a class="header-anchor" href="#函数基础" aria-hidden="true">#</a> 函数基础</h1><p>函数（Function）：特殊的对象，可以执行。</p><h2 id="函数的概念" tabindex="-1"><a class="header-anchor" href="#函数的概念" aria-hidden="true">#</a> 函数的概念</h2><ul><li>实现特定功能的多条语句的封装体</li><li>只有函数是可以执行的</li><li>函数也是对象</li><li>函数中可以封装一些功能（代码），在需要时可以只写这些功能和代码</li><li>可以将要封装的的代码以<strong>字符串的形式</strong>传递给构造函数</li><li>封装的代码不会立即执行</li><li>函数代码会在函数调用的时候执行，</li><li>所有的函数，都是 Function 的“实例”（或者说是“实例对象”）。函数本质上都是通过 new Function 得到的。</li><li>函数既然是实例对象，那么，函数也属于“对象”。</li></ul><h2 id="创建函数对象" tabindex="-1"><a class="header-anchor" href="#创建函数对象" aria-hidden="true">#</a> 创建函数对象</h2><ol><li><p>以构造函数的方式创建函数：</p><ul><li><code>var fun = new Function();</code></li><li>实际开发中，不会使用这种方式</li></ul></li><li><p>使用函数声明来创建函数：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code> <span class="token keyword">function</span> <span class="token function">函数名</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">[</span>形参<span class="token number">1</span><span class="token punctuation">,</span>形参<span class="token number">2.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>形参<span class="token constant">N</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   语句<span class="token operator">...</span>
 <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>备注：语法中的中括号，表示“可选”</li></ul></li><li><p>函数表达式（匿名函数）</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code> <span class="token keyword">var</span> <span class="token function-variable function">变量名</span>  <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">[</span>形参<span class="token number">1</span><span class="token punctuation">,</span>形参<span class="token number">2.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>形参<span class="token constant">N</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   语句<span class="token operator">...</span><span class="token punctuation">.</span>
 <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">fun2</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;我是匿名函数中封装的代码&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h2 id="函数的调用" tabindex="-1"><a class="header-anchor" href="#函数的调用" aria-hidden="true">#</a> 函数的调用</h2><ul><li>普通函数的调用，语法：<code>函数();</code>或者<code>函数名.call();</code>。</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>通过对象的方法来调用，如果一个函数是作为一个对象的属性保存，那么，我们称这个函数是这个对象的方法。</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>obj<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>立即执行函数</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;匿名函数&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>通过构造函数来调用</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">new</span> <span class="token class-name">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>临时将一个函数作为指定对象的方法调用</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>fun<span class="token punctuation">.</span>call <span class="token operator">/</span> <span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>apply 与 call 的唯一<strong>区别</strong>就是：<strong>调用 apply 方法时的参数，实参应该是以数组的形式来书写</strong>。</p><ul><li>绑定事件函数</li><li>定时器函数</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  num<span class="token operator">++</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="形参和实参" tabindex="-1"><a class="header-anchor" href="#形参和实参" aria-hidden="true">#</a> 形参和实参</h2><p>形参：</p><ul><li>形式上的参数。定义函数时传递的参数，当时并不知道是什么值。</li><li>定义函数时，可以在函数的()中来指定一个或多个形参。</li><li>多个形参之间使用,隔开，声明形参就相当于在函数内部声明了对应的变量，但是并不赋值。</li></ul><p>实参：</p><ul><li>概念：实际上的参数。调用函数时传递的参数，实参将会传递给函数中对应的形参。</li><li>在调用函数时，可以在函数的 ()中指定实参。</li><li>实际参数和形式参数的个数，一般要相同。</li><li>如果实参的数量少于形参的数量，多余的形参会被定义为 <code>undefined</code></li><li>如果实参的数量多余形参的数量，多余实参不会被赋值。</li><li>实参可以是任意数据类型，当需要传递的实参过多时，可以封装到对象中传递。</li></ul><p>在 JS 中，形参的默认值是 <code>undefined</code>。</p><h2 id="函数的返回值" tabindex="-1"><a class="header-anchor" href="#函数的返回值" aria-hidden="true">#</a> 函数的返回值</h2><ul><li>可以使用 return 来设置函数的返回值，语法：<code>return 值;</code></li><li><code>return</code>后的值将作为函数的执行结果返回</li><li>定义一个变量来接收该结果</li><li>在函数中，<code>return</code>后的语句都不再执行</li><li>如果函数中不写 return 或者 return 后面不写值，都返回<code>undefined</code></li><li>返回值可以是任意的数据类型</li><li><code>return</code> 只能返回一个值。如果用逗号隔开多个值，则以最后一个为准</li><li>fn 代表的是整个函数，而 fn()代表的是返回值。</li></ul><h2 id="作用域" tabindex="-1"><a class="header-anchor" href="#作用域" aria-hidden="true">#</a> 作用域</h2><p>作用域指一个变量作用的范围，在 JS 中有两种作用域：</p><ul><li><p>全局作用域</p><ul><li>直接编写到 script 标签中的 JS 代码，都在全局作用域</li><li>全局作用域在页面打开时创建，关闭时销毁</li><li>在全局作用域中有一个全局对象 window，代表浏览器的窗口，由浏览器创建，我们可以直接使用</li><li>在全局作用域中，我们创建的变量都会作为 window 对象的属性保存</li><li>创建的函数会作为 window 对象的方法保存</li><li>全局作用域中的变量都是全局变量，在页面的任意部分都可以访问</li></ul></li><li><p>函数作用域</p><ul><li>调用函数时创建函数作用域，函数执行完毕后，函数作用域销毁</li><li>每调用一次函数就会创建一个新的作用域，他们是相互独立的</li><li>在函数作用域中可以访问到全局作用域的变量</li><li>全局作用域无法访问到函数作用域的变量</li><li>当在函数作用域中操作变量时，会先在自身作用域中寻找，有就直接使用，没有则向上一级作用域寻找。直到全局作用域，没找到就报错</li><li>在函数中访问全局的变量可以使用 window 对象</li><li>在函数作用域中也有声明提前，使用 var 和 function 都会声明提前</li><li>在函数作用域中不使用 var 声明的变量都会称为全局变量</li><li>定义形参相当于在函数作用域中声明了变量</li></ul></li></ul><h2 id="变量的声明提前" tabindex="-1"><a class="header-anchor" href="#变量的声明提前" aria-hidden="true">#</a> 变量的声明提前</h2><p>使用 var 关键字声明的变量，会在所有的代码执行前被声明（但是不会被赋值）。但是如果声明变量时不使用 var 关键字，变量不会声明提前。</p><p>函数的声明提前</p><ul><li>使用函数声明创建的函数<code>function fun(){}</code>，会在所有的代码执行之前就被创建，我们可以在函数声明前调用函数。</li><li>使用函数表达式创建的函数<code>var fun = function(){}</code>不会声明提前</li></ul><h2 id="this" tabindex="-1"><a class="header-anchor" href="#this" aria-hidden="true">#</a> this</h2><p>解析器（浏览器）在调用函数时，每次都会向函数内部传递进一个隐含的参数，这个隐含的的参数就是 this。</p><ul><li>this 指向一个对象，这个对象我们称为函数的执行上下文对象</li><li>根据函数的调用的方式不同，this 会指向不同的对象</li><li>以函数的形式调用时，this 永远都是 window</li><li>以方法的形式调用时，this 就是调用这个方法的对象</li><li>以构造函数的形式调用时，this 就是实例，即<code>var per = new Person();</code>的<code>per</code></li><li>以 call()和 apply()调用时，this 是指定的那个对象，即<code>fun.call(obj1)和fun.apply(obj2);</code>中的 obj1 和 obj2</li><li>在事件的响应函数中，响应函数是给谁绑定的，this 就是谁，即<code>btn.onclick = function () {console.log(this);}</code>，此时，this 是 btn</li></ul><h2 id="arguments" tabindex="-1"><a class="header-anchor" href="#arguments" aria-hidden="true">#</a> arguments</h2><p>调用函数时的隐含参数除了 this 还有 arguments</p><ul><li>arguments 是封装实参的对象</li><li>是一个类数组对象，它也可以通过索引操作数据，获取长度</li><li>在调用函数时，我们所传递的实参都会在 arguments 中保存</li><li>arguments.length 可以获取实参的长度</li><li>我们即使不定义形参，也可以通过 arguments 来使用实参</li><li><code>arguments[0]、arguments[1]</code>分别表示第一个，第二个实参</li><li><code>arguments.callee</code>这个属性对应一个函数对象，就是当前正在指向的函数的对象</li><li><code>arguments.callee ===fun // true</code></li></ul><h2 id="工厂模式创建对象" tabindex="-1"><a class="header-anchor" href="#工厂模式创建对象" aria-hidden="true">#</a> 工厂模式创建对象</h2><p>使用工厂方法创建对象，通过该方法可以大批量创建对象.</p><ul><li>创建一个函数</li><li>函数里创建一个新的对象</li><li>对象里添加属性</li><li>将新的对象通过 return 作为函数值返回</li><li>从外面传递参数</li></ul><p>这种方法使用的构造函数都是 Object，所以创建的对象都是 Object 这个类型，就导致我们无法区分多种不同类型的对象。</p><h2 id="构造函数创建对象" tabindex="-1"><a class="header-anchor" href="#构造函数创建对象" aria-hidden="true">#</a> 构造函数创建对象</h2><ul><li>创建一个构造函数，专门创建 Person 对象（Person 类）</li><li>构造函数就是一个普通的函数，创建方式和普通函数没什么区别</li><li>不同的是构造函数习惯首字母大写</li><li>构造函数和普通函数的区别就是调用的方式不同</li><li>普通函数直接调用，构造函数需要使用 new 关键字调用<code>var per = new Person;</code></li><li>使用同一类构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类（Person 类），创建的对象称为该类的实例，或者该构造函数的实例。<code>per是Person类的实例</code></li></ul><p>构造函数的执行流程：</p><ul><li>立即创建一个新的对象</li><li>将新建的对象设置为函数的 this，在构造函数中可以使用 this 来引用新建的对象</li><li>逐行执行函数中的代码</li><li>将新建的对象作为返回值返回</li></ul><p>通过 instanceof 可以检查一个对象是否是一个类的实例</p><ul><li><code>对象 instanceof 构造函数</code></li><li>是则返回 true，不是则返回 false</li></ul><p>所有的对象都是 Object 构造函数的实例</p><p>将函数定义在全局作用域中，会污染全局作用域的命名空间，也很不安全。</p><p>JavaScript 的构造函数中可以添加一些成员，可以在构造函数本身上添加，也可以在构造函数内部的 this 上添加。通过这两种方式添加的成员，就分别称为静态成员和实例成员。</p><ul><li>静态成员：在构造函数本上添加的成员称为静态成员，只能由构造函数本身来访问。</li><li>实例成员：在构造函数内部创建的对象成员称为实例成员，只能由实例化的对象来访问。</li></ul><h2 id="高阶函数" tabindex="-1"><a class="header-anchor" href="#高阶函数" aria-hidden="true">#</a> 高阶函数</h2><p>当函数 A 接收函数 B 作为参数，或者把函数 C 作为返回值输出时，我们称函数 A 为高阶函数。高阶函数是对其他函数进行操作的函数。</p><ul><li>把其他函数作为参数</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> f</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
  f <span class="token operator">&amp;&amp;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">fn1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;我是一个函数&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>把其他函数作为返回值</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>变量 a 是函数内的局部变量，所以外部无法访问。</p><h2 id="闭包" tabindex="-1"><a class="header-anchor" href="#闭包" aria-hidden="true">#</a> 闭包</h2><ul><li>有权访问另一个函数作用域中变量的函数称为闭包。</li><li>闭包是一种函数，闭包是一种现象。</li><li>这个作用域可以访问另一个函数内部的局部变量，就产生了闭包（这时理解为一种现象），另外那个作用域所在的函数称之为闭包函数。</li><li>强调的是访问局部变量</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//在 chrome 浏览器控制台中，设置断点，可以调试闭包Closure</span>
  <span class="token punctuation">}</span>
  <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>函数 fn2 的作用域访问了 fn1 中的局部变量，此时，fn1 中就产生了闭包，fn1 称之为闭包函数。</li><li>一般来说，在 fn1 函数执行完毕后，它里面的变量 a 会立即销毁</li><li>由于产生了闭包，所以 fn1 函数中的变量 a 不会立即销毁，因为 fn2 函数还要继续调用变量 a</li><li>只有等所有函数把变量 a 调用完了，变量 a 才会销毁。</li><li>闭包的主要作用就是：延伸了变量的作用范围。</li></ul>`,66),l=[t];function p(c,o){return a(),s("div",null,l)}const d=n(i,[["render",p],["__file","10_js_function.html.vue"]]);export{d as default};
