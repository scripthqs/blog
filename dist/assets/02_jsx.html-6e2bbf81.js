import{_ as a,o as s,c as n,f as e}from"./app-c6441670.js";const i={},l=e(`<h1 id="jsx-简介" tabindex="-1"><a class="header-anchor" href="#jsx-简介" aria-hidden="true">#</a> JSX 简介</h1><p>JSX 是一种 JavaScript 的语法扩展（eXtension），也在很多地方称之为 JavaScript XML，因为看起就是一段 XML 语法。</p><ul><li>用于描述我们的 UI 界面，并且其完成可以和 JavaScript 融合在一起使用</li><li>不同于 Vue 中的模块语法，不需要专门学习模块语法中的一些指令（比如 v-for、v-if、v-else、v-bind）</li></ul><p>React 认为渲染逻辑本质上与其他 UI 逻辑存在内在耦合，所以选择 JSX。</p><h2 id="jsx-规范" tabindex="-1"><a class="header-anchor" href="#jsx-规范" aria-hidden="true">#</a> JSX 规范</h2><ol><li>JSX 的顶层只能有一个根元素，所以很多时候会在外层包裹一个 div 元素</li><li>在 JSX 的外层包裹一个小括号()，这样可以方便阅读，并且 jsx 可以进行换行书写</li><li>JSX 中的标签可以是单标签，也可以是双标签；如果是单标签，必须以<code>/&gt;</code>结尾；</li></ol><h2 id="jsx-语法" tabindex="-1"><a class="header-anchor" href="#jsx-语法" aria-hidden="true">#</a> JSX 语法</h2><p>JSX 注释</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">return</span> <span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">{</span><span class="token comment">/* JSX的注释写法 */</span><span class="token punctuation">}</span>
    <span class="token operator">&lt;</span>h2<span class="token operator">&gt;</span><span class="token punctuation">{</span>message<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>JSX 嵌入表达式</p><ul><li>运算表达式</li><li>三元运算符</li><li>执行一个函数</li></ul><p>JSX 绑定属性</p><ul><li>元素都会有 title 属性</li><li>img 元素会有 src 属性</li><li>a 元素会有 href 属性</li><li>元素可能需要绑定 class</li><li>原生使用内联样式 style</li></ul><h2 id="react-事件绑定" tabindex="-1"><a class="header-anchor" href="#react-事件绑定" aria-hidden="true">#</a> React 事件绑定</h2><ul><li>React 事件的命名采用小驼峰式（camelCase），而不是纯小写</li><li>通过<code>{}</code>传入一个事件处理函数，这个函数会在事件发生时被执行；</li></ul><h3 id="相关-js-知识" tabindex="-1"><a class="header-anchor" href="#相关-js-知识" aria-hidden="true">#</a> 相关 js 知识</h3><p>this 的四种绑定规则:</p><ol><li>默认绑定 独立执行 foo()</li><li>隐式绑定 被一个对象执行 obj.foo() -&gt; obj</li><li>显式绑定: call/apply/bind foo.call(&quot;aaa&quot;) -&gt; String(&quot;aaa&quot;)</li><li>new 绑定: new Foo() -&gt; 创建一个新对象, 并且赋值给 this</li></ol><p>super 和 constructor</p><p>super 关键字用于访问对象字面量或类的原型（[[Prototype]]）上的属性，或调用父类的构造函数。</p><ol><li>作为“函数调用”<code>super(...args)</code></li><li>作为“属性查询”<code>super.prop 和 super[expr]</code></li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 注意：在派生的类中，在你可以使用 &#39;this&#39; 之前，必须先调用 super()。</span>
<span class="token comment">// 然后使用 &#39;this&#39; 了，忽略 &#39;this&#39; 将导致引用错误（ReferenceError）</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>在 JavaScript class 中，每次你定义其子类的构造函数时，都需要调用 super 方法。 因此，在所有含有构造函数的的 React 组件中，构造函数必须以 super(props) 开头。</p></blockquote><h2 id="react-列表渲染" tabindex="-1"><a class="header-anchor" href="#react-列表渲染" aria-hidden="true">#</a> React 列表渲染</h2><p>在 React 中，没有 Vue 的模板语法，对 Js 的要求会更高，</p><ul><li>展示列表最多的方式就是使用数组的 map 高阶函数，</li><li>过滤掉一些内容使用 filter 函数</li><li>截取数组中的一部分内容使用 slice 函数</li></ul><p>列表展示的 jsx 中也需要添加一个 key，目的是为了提高 diff 算法时的效率。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 方法用一个固定值填充一个数组</span>
<span class="token function">fill</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">fill</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> start<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">fill</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 从起始索引到终止索引内的全部元素。不包括终止索引</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="数据的不可变性" tabindex="-1"><a class="header-anchor" href="#数据的不可变性" aria-hidden="true">#</a> 数据的不可变性</h2><p>一般来说改变数据有 2 种方式：</p><ol><li>直接修改变量的值</li><li>是使用新的一份数据替换旧数据(不直接修改)</li></ol><p>最好使用不直接修改数据的方式，好处：</p><ol><li>做撤销和恢复</li><li>追踪数据的改变</li></ol>`,33),t=[l];function p(c,o){return s(),n("div",null,t)}const u=a(i,[["render",p],["__file","02_jsx.html.vue"]]);export{u as default};
