import{_ as e,o as a,c as i,f as l}from"./app-10c4e004.js";const s={},n=l(`<h1 id="面试" tabindex="-1"><a class="header-anchor" href="#面试" aria-hidden="true">#</a> 面试</h1><h2 id="自我介绍" tabindex="-1"><a class="header-anchor" href="#自我介绍" aria-hidden="true">#</a> 自我介绍</h2><p>你好，我叫黄前胜，目前做了 4 年前端，毕业于重庆交通大学，学历是本科，最近使用的技术栈主要是 vue2/3,还有 electron,react hooks 那一套也会，写过一些示例，最近是做了一个制造运营管理系统，包括 web 端和 electron 客户端。还有一个低代码平台，可视化项目。再之前还做过 ssr 服务端渲染的项目。</p><ul><li>从头到尾：从基建到后期优化都有参与</li></ul><p>制造运营管理系统：web 端：权限菜单管理、业务基础数据、工单、产品配置、工艺路线等等业务。客户端：流水线，过站扫码、称重、包装、组装、打标。这个系统就是给国内外各个工厂去使用，包括重庆、南昌、深圳、印度、土耳其等国内外多个工厂。</p><h2 id="八股文" tabindex="-1"><a class="header-anchor" href="#八股文" aria-hidden="true">#</a> 八股文</h2><ul><li>css 常见布局 flex 自适应（百分比+flex vh/vw） rem px em 单位</li><li>输入 url 到看到整个页面，http http2 https</li><li>promise 微任务宏任务</li><li>原型链 作用域 精度问题</li></ul><h2 id="框架工具" tabindex="-1"><a class="header-anchor" href="#框架工具" aria-hidden="true">#</a> 框架工具</h2><ul><li>vue 响应式、diff 算法、虚拟 dom，vue 依赖收集</li><li>watch computed nextTick vue2/vue3 v-if/v-show v-if/v-for</li><li>ref/reactive</li><li>webpack plugin loader vite</li><li>react</li></ul><h2 id="项目" tabindex="-1"><a class="header-anchor" href="#项目" aria-hidden="true">#</a> 项目</h2><ul><li>webpack +vite 打包</li><li>vxe-table 动态表单 水印 el-select 多个 tag 才省略</li><li>vue hooks</li><li>echarts 动画 响应式布局</li><li>ai 翻译、客户、iframe 事件通信 postMessage、eval 函数执行代码字符串</li><li>ssr nuxt3 svg 动画 过渡 seo 语义化</li><li>微前端 monorepo</li><li>uniapp</li><li>代码规范 css bem 块元素修饰符 样式 vue watch 函数入参 try catch</li><li>监听滚动，判断底部，触发网络请求 scrollTop+windowHeight&gt;= scrollHeight</li><li>document。visibilityState：页签活跃</li><li>css 的 text-overflow js slice 方法</li><li>重复请求：加请求锁 flag,按钮 loading,防抖节流</li><li>批量请求，只弹出一个提示，allSettled all</li><li>用 map 映射，策略模式，减少 if-else</li><li>px-&gt;rem:通常设计稿和和根字体是 1/10 meta 视口缩放</li><li>静态资源同源宽松 CDN 通常会设置 CORS 响应头</li><li>空对象 object.keys(ojb).length</li><li>空数组：Array.isArray(arr) &amp;&amp; arr.length === 0;</li><li>flex:1 多个元素等比自适应 平均分配</li><li>iframe 隔离太强，交互困难 不利于 路由权限样式不好做</li><li>qiankun 利用 ES6 的 Proxy 对 window 对象进行代理，拦截子应用对全局变量的读写。</li><li>css 水印伪元素，Canvas 背景</li><li>全部变量污染，冲突，难以维护</li><li>seo 语义化标签 alt 属性 title 和 description ssr 服务端渲染 直接返回完整 HTML，</li><li>script.onerror 加载失败降级处理 cdn 兜底</li><li>data- 属性自定义数据，且不会影响页面结构和样式。</li><li>sideEffects 标记哪些文件有副作用，帮助构建工具（如 webpack）进行 Tree Shaking（去除未用代码）优化。</li><li>requestIdleCallback 浏览器空闲时执行回调函数</li><li>懒加载、路由守卫、路由参数</li></ul><h3 id="webpack-vite" tabindex="-1"><a class="header-anchor" href="#webpack-vite" aria-hidden="true">#</a> webpack-&gt;vite</h3><p>webpack 遍历依赖全量打包启动服务器，慢，配置复杂 vite 使用浏览器原生 es-module,按需编译动态加载，配置简单</p><p>vite 预编译 处理 commonjs</p><ul><li>vue 版本</li><li>vite 插件</li><li>index.html</li><li>环境变量 p<wbr>rocess.env -&gt;i<wbr>mport.meta.env define 配置</li><li>require.context-&gt;i<wbr>mport.meta.glob</li><li>配置别名 resolve.alias</li><li>自动为文件加后缀 resolve.extensions</li><li>sass 降级</li><li>variables.scss-&gt;variables.module.scss</li></ul><p>打包：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// process.argv.slice(2);</span>
<span class="token comment">// node 子进程</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> spawn <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;child_process&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// 写一个env.temp 的环境变量</span>
<span class="token comment">// spawn(npxCmd, [&quot;vite&quot;, &quot;build&quot;, &quot;--mode&quot;, &quot;temp&quot;]</span>
<span class="token comment">// 删除env.temp</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>build<span class="token punctuation">.</span>rollupOptions<span class="token punctuation">.</span>output<span class="token punctuation">;</span>
<span class="token comment">// manualChunks(id) {</span>
<span class="token comment">//   if (id.includes(&quot;node_modules&quot;)) {</span>
<span class="token comment">//     // 让每个插件都打包成独立的文件</span>
<span class="token comment">//     return id .toString() .split(&quot;node_modules/&quot;)[1] .split(&quot;/&quot;)[0] .toString();</span>
<span class="token comment">//   }</span>
<span class="token comment">// }</span>
<span class="token comment">// import _ from &quot;lodash-es&quot;; // 你将会把整个lodash的库引入到项目</span>
<span class="token comment">// import { cloneDeep } from &quot;lodash-es&quot;; // 你将会把引入cloneDeep引入到项目</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码分割原理：vite rollup 默认是有 es6 的 import 语法 自动分割，manualChunks 函数手动分割 id 绝对路径</p><ul><li>换成了挂 window 下面</li></ul><p>vite 插件 preload（立即加载)和 prefetch(空闲时预加载）预加载资源</p><ul><li><p>首屏大图、重要脚本、样式</p></li><li><p>首页懒加载，进去有点卡顿，使用 vite 插件构建预加载</p></li><li><p>output.mainfest 生成资源清单，描述打包后的每个入口和资源文件的映射关系</p></li><li><p>path 字符串数组 打包资源路径路径</p></li><li><p>构造一个 preload 的 script 标签，添加到 index.html 中</p></li><li><p>transformIndexhtml 传 html</p></li></ul><p>echarts 按需引入</p><ul><li>只引入核心库，引入需要的图表，组件</li></ul><p>处理第三方库组件没有提供的效果</p><ol><li>css 控制视觉显影效果，虚伪达成</li><li>js 回归原始的 dom 操作</li></ol><h2 id="vue2-和-vue3" tabindex="-1"><a class="header-anchor" href="#vue2-和-vue3" aria-hidden="true">#</a> vue2 和 vue3</h2><ol><li>defineProperty 该为 Proxy,解决数组无法通过下标修改，对象属性增减的问题</li><li>选项式 api 改为组合式编程，方便按需引入，配合 tree-shaking 打包体积变小</li><li>vue3 的 mixin 改为 hooks 组件优先</li><li>v-model 监听的事件和传递值不一样 <ul><li>vue2 value，change</li><li>vue3 传递 modelValue，监听 update:modelValue</li></ul></li></ol><p>watch/watchEffect/computed</p><ul><li><p>state、getters、actions 等同于 Vue2 中的 data、computed、methods</p></li><li><p>可以直接在 store 上访问 state、getters、actions 中定义的属性</p></li><li><p>render 函数 cre</p></li></ul><p>Vuex 需要定义 State、Getters、Mutations、Actions、Modules</p><ul><li>更新唯一方式就是提交 mutations。mutation 必须是同步函数</li><li>mutation 必须同步，action 支持异步</li></ul><h2 id="ref-和-reactive-computed-watch" tabindex="-1"><a class="header-anchor" href="#ref-和-reactive-computed-watch" aria-hidden="true">#</a> ref 和 reactive computed watch</h2><p>ref:支持基本数据类型+引用数据类型 reactive:只支持引用数据类型</p><p>他们解构后都会丢失响应式，需要使用 toRefs。</p><p>ref 和 reactive 都可以定义对象、数组，具体使用哪个根据赋值方式来定</p><ul><li>直接赋值：ref 会保留响应式，reactive 会丢失响应式</li><li>修改数据：reactive 和 ref 都可以，但是 ref 需要多写个.value，vscode 可以提供插件自动补全 ref</li></ul><h2 id="diff-算法" tabindex="-1"><a class="header-anchor" href="#diff-算法" aria-hidden="true">#</a> diff 算法</h2><p>框架设计，数据发生改变，引用数据的视图发生改变。</p><p>虚拟 dom 用 js 对象模拟 dom 结构，通过 diff 算法比较新旧 dom，减少不必要的 dom 更新，跨平台</p><ul><li>同层比较和优化策略</li><li>三大核心操作：移动节点、更新节点、新增和删除节点</li><li>差异记录和批量更新</li></ul><p>v-for 的 key 作用</p><ul><li>key 属性是 dom 元素的唯一标识， 可以在 diff 算法用来判断是否是同一个节点</li><li>可以调高虚拟 dom 的更新效率：使用 index 做 key，破坏顺序操作的时候， 因为每一个节点都找不到对应的 key，导致部分节点不能复用,所有的新 vnode 都需要重新创建。</li><li>不设置 key 或者 key 不唯一可能会有 bug：结构中包含输入类的 DOM，会产生错误的 DOM 更新</li><li>数据没有逆序添加，逆序删除破坏顺序的操作， 只用于列表展示的话 使用 index 作为 Key 没有毛病</li></ul><h2 id="hooks" tabindex="-1"><a class="header-anchor" href="#hooks" aria-hidden="true">#</a> hooks</h2><ol><li>函数名前缀加上 use；</li><li>合理利用 Vue 提供的响应式函数及生命周期</li><li>暴露出 变量 和 方法 提供外部需要时使用</li></ol><h2 id="封装组件" tabindex="-1"><a class="header-anchor" href="#封装组件" aria-hidden="true">#</a> 封装组件</h2><ul><li>单一职责</li><li>高内聚低耦合，内部的功能紧密相关，减少组件之间的依赖</li><li>灵活的 slot，props 必填选填明确，使用默认值</li><li>像 css 使用 BEM 命名 回调事件以 on 开头，组件内事件以 handle 开头 ，私有方法以 _ 开头</li><li>使用 computed 对 props 进行二次封装</li></ul><h2 id="ts" tabindex="-1"><a class="header-anchor" href="#ts" aria-hidden="true">#</a> ts</h2><p>数组对象不定属性</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> arr<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">(</span><span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> obj<span class="token operator">:</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> <span class="token punctuation">[</span>propsName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token string">&quot;123&quot;</span><span class="token punctuation">,</span> a<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>泛型</p><ul><li>来在定义时不指定具体类型，使用时再指定类型</li><li>泛型约束，extends</li></ul><p>类型工具</p><ul><li><code>Partial&lt;IPerson&gt;</code> 变可选</li><li><code>Required&lt;IPerson&gt;</code> 变必填</li><li><code>Readonly</code> 只读</li><li><code>Record&lt;Keys, Type&gt;</code> 构造一个对象类型</li><li><code>ReturnType</code> 返回值</li><li>Pick&lt;T, K&gt; 挑选部分属性组成新类型。</li><li>Omit&lt;T, K&gt; 去除部分属性组成新类型。</li></ul><p>declare 声明模块、变量、文件、空间等</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">// 引入vue文件不识别</span>
<span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">&quot;*.vue&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>tsconfig.json</p><ul><li>compilerOptions <ul><li>&#39;jsx&#39;:&#39;prev&#39;</li></ul></li><li>include</li><li>exclude</li></ul><p>常用</p><ul><li>泛型 vue 网络请求 page 出参入参</li><li>package.json 中找 exports 下的 types</li><li>HTMLInputElement HTMLCanvasElement</li></ul><h2 id="react" tabindex="-1"><a class="header-anchor" href="#react" aria-hidden="true">#</a> react</h2><p>React 在 props 或 state 发生改变时，会调用 React 的 render 方法，会创建一棵不同的树。造成父组件 state 数据一遍，子组件就更新。</p><ul><li>React 需要基于这两个不同的树之间的差别来判断如何有效的更新 UI</li><li>React 进入了 diff 算法来优化</li><li>vue 源码自动依赖收集</li><li>react 需要使用 React.memo 包装组件</li><li>父组件传递给子组件的方法用 useCallback 包装一下</li><li>js 三元运算、map 便利 == vue 的 v-if/v-show v-for</li><li>onClick、onChange == @click、@input</li><li>const [value, setValue] = useState(&#39;&#39;) == v-model</li><li>useState == vue 直接改</li><li>useEffect == vue 生命周期（依赖数组为空） == vue 的 watch（依赖数组有值） useLayoutEffect 同步操作 dom，避免闪烁</li><li>useMemo == vue computed</li><li>useRef 获取 ref ,也可以保存一些不会引入组件渲染的数据</li><li>使用组件的方法或者属性，使用 useImperativeHandle</li><li>useImperativeHandle 配合 forwardRef 使用，自定义暴露给父组件的实例值</li><li>Umi 预定式路由 插件 mock 代理 unocss ts 代码规范</li><li><strong>styled-components</strong> 库 模板字符串的高级用法 css-modules(不能连接符、style.className、动态修改样式名字)</li></ul><h2 id="performanceobserver" tabindex="-1"><a class="header-anchor" href="#performanceobserver" aria-hidden="true">#</a> PerformanceObserver</h2><ul><li>实时捕获页面性能事件，FCP 首次内容绘制</li><li>长任务，超过 50ms 的任务 使用 PerformanceObserver</li><li>beforeunload visibilitychange 事件，监听页面关闭</li><li>navigator.sendBeacon 在页面关闭或切换时发送积压的埋点数据，保证数据可靠上报。</li><li>埋点数据：加载页面、路由切换、点击、滑动、接口</li><li>统计加载耗时</li><li></li></ul><h2 id="公司" tabindex="-1"><a class="header-anchor" href="#公司" aria-hidden="true">#</a> 公司</h2><p>架构 人员配比 试用期 福利待遇 年终奖金</p>`,67),t=[n];function o(p,r){return a(),i("div",null,t)}const u=e(s,[["render",o],["__file","resume.html.vue"]]);export{u as default};
