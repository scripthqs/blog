import{_ as i,o as l,c as e,f as a}from"./app-007a9be1.js";const r={},o=a('<h1 id="函数、对象高级" tabindex="-1"><a class="header-anchor" href="#函数、对象高级" aria-hidden="true">#</a> 函数、对象高级</h1><h2 id="原型与原型链" tabindex="-1"><a class="header-anchor" href="#原型与原型链" aria-hidden="true">#</a> 原型与原型链</h2><h3 id="原型-prototype" tabindex="-1"><a class="header-anchor" href="#原型-prototype" aria-hidden="true">#</a> 原型(prototype)</h3><ul><li>每个函数对象都有一个 prototype 属性，该属性默认对应一个<code>{}</code>(空对象)，称为原型对象。这个空对象<code>{}</code>是 Object 的实例对象。</li><li>原型对象都有一个 constructor 属性，指向函数对象。</li></ul><p>空对象表示没有我们自己添加的属性。</p><p>给原型对象添加属性（方法）===》实例对象可以访问。</p><h3 id="显式原型和隐式原型" tabindex="-1"><a class="header-anchor" href="#显式原型和隐式原型" aria-hidden="true">#</a> 显式原型和隐式原型</h3><ul><li>每个函数对象都有一个 prototype 属性，称为显式原型属性，默认指向<code>{}</code>空实例对象。</li><li>每个实例对象都有一个<strong>proto</strong>属性，称为隐式原型属性。</li><li>构造函数对象的显示原型===实例对象的隐式原型 <ul><li>Function 是 new Function()产生的</li><li>Object 也是 new Function()产生的</li></ul></li><li>所有函数的<strong>proto</strong>都是一样的</li><li>函数的 prototype 属性：在定义函数时自动添加的，默认值是 Object 空对象。</li><li>对象的<strong>proto</strong>属性：创建对象时自动添加的，默认值为构造函数的 prototype 属性值。</li><li>不要直接操作隐式原型(ES6 之前)。</li></ul><h3 id="原型链" tabindex="-1"><a class="header-anchor" href="#原型链" aria-hidden="true">#</a> 原型链</h3><ul><li>访问一个对象的属性，先在自身寻找，找到返回</li><li>找不到沿着<strong>proto</strong>这条链找，找到返回</li><li>最终没找到，返回 undefined</li><li>原型链别名隐式原型链</li></ul><p>作用：查找对象属性（方法）</p><h3 id="原型的继承" tabindex="-1"><a class="header-anchor" href="#原型的继承" aria-hidden="true">#</a> 原型的继承</h3><ul><li>构造函数的实例对象自动拥有构造函数原型对象的属性（方法）</li><li>原理：原型链</li></ul><ol><li>所有函数的显示原型指向的对象是空 Object 实例对象(Object 不满足) <ul><li><code>Object.prototype instanceof Object</code>//false</li></ul></li><li>所有函数都是 Function 的实例，包括 Function 本身和 Object <ul><li><code>Function.__proto__===Function.prototype</code></li></ul></li><li>Object 的原型对象是原型链的尽头 <ul><li><code>object.prototype.__proto__</code>//null</li></ul></li></ol><h3 id="instanceof" tabindex="-1"><a class="header-anchor" href="#instanceof" aria-hidden="true">#</a> instanceof</h3><ul><li>A instanceof B</li><li>如果 B 函数的显式原型对象在 A 对象的原型链上，返回 true，否则返回 false。</li></ul><h2 id="回调函数" tabindex="-1"><a class="header-anchor" href="#回调函数" aria-hidden="true">#</a> 回调函数</h2><p>什么是回调函数？</p><ul><li>你定义的</li><li>你没有调用</li><li>但最终函数执行了</li></ul><p>常见的回调函数？</p><ul><li>DOM 事件的回调函数</li><li>定时器回调函数</li><li>Ajax 请求回调函数</li><li>生命周期回调函数</li></ul><h2 id="iife" tabindex="-1"><a class="header-anchor" href="#iife" aria-hidden="true">#</a> IIFE</h2><p>IIFE；Immediately-Invoked Function Expression（立即调用的函数表达式），也称为<code>匿名函数自调用</code></p><p>使用 IIFE 的好处：</p><ul><li>不必为函数命名，避免了污染全局变量</li><li>IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。</li></ul><h2 id="this" tabindex="-1"><a class="header-anchor" href="#this" aria-hidden="true">#</a> this</h2><ul><li><code>fun()</code>this 是 window</li><li><code>obj.fun()</code>this 是 obj</li><li><code>var p = new test()</code>this 是新建的对象 p</li><li><code>p.call(obj)</code>this 是 obj</li></ul><h2 id="闭包" tabindex="-1"><a class="header-anchor" href="#闭包" aria-hidden="true">#</a> 闭包</h2><p>闭包产生的条件：</p><ul><li>函数嵌套。</li><li>内部函数引用了外部函数的数据（变量/函数）</li></ul><p>通过 chrome 调试工具可以查看闭包</p><ul><li>闭包是一种函数，闭包是一种现象。</li></ul><h3 id="常见的闭包" tabindex="-1"><a class="header-anchor" href="#常见的闭包" aria-hidden="true">#</a> 常见的闭包</h3><ol><li>将一个函数作为另一个函数的返回值</li><li>将函数作为实参传递给另一个函数</li></ol><h3 id="闭包的作用" tabindex="-1"><a class="header-anchor" href="#闭包的作用" aria-hidden="true">#</a> 闭包的作用</h3><ul><li>函数执行完后，延长变量的生命周期</li><li>让函数外部可以操作内部的数据变量</li><li>在函数执行完后，函数内部的局部变量一般不会存在，除了闭包中的变量。</li><li>函数外部不能访问函数内部的局部变量，但可以通过闭包让外部来操作内部的局部变量。</li></ul><h3 id="闭包的产生和死亡" tabindex="-1"><a class="header-anchor" href="#闭包的产生和死亡" aria-hidden="true">#</a> 闭包的产生和死亡</h3><ul><li>在嵌套内部函数时就产生了（不是调用）</li><li>在嵌套的内部函数成为垃圾对象时死亡 f=null</li></ul><h3 id="闭包的应用" tabindex="-1"><a class="header-anchor" href="#闭包的应用" aria-hidden="true">#</a> 闭包的应用</h3><p>定义 JS 模块</p><ul><li>具有特定功能的 JS 文件</li><li>将所有数据和功能都封装到一个函数内部（私有的）</li><li>只向外暴露一个包含 n 个方法的对象和函数</li><li>模块的使用者，只需要通过模块暴露的对象调用方法来实现对应的功能</li></ul><p>如何向外暴露方法：通过 return 或者在函数内部添加 window 的方法</p><h3 id="闭包的的缺点" tabindex="-1"><a class="header-anchor" href="#闭包的的缺点" aria-hidden="true">#</a> 闭包的的缺点</h3><ul><li>函数执行完后，函数内的局部变量没有释放，占用内存时间会变长。</li><li>要即使释放<code>f = null</code></li></ul><h3 id="内存溢出和内存泄漏" tabindex="-1"><a class="header-anchor" href="#内存溢出和内存泄漏" aria-hidden="true">#</a> 内存溢出和内存泄漏</h3><p>内存溢出：</p><ul><li>当程序运行所需的内存超过了剩余的内存，就会抛出内存溢出错误</li></ul><p>内存泄漏：</p><ul><li>内存泄露指用不到（访问不到）的变量，依然占据这内存空间，不能被再次利用。</li><li>占用的内存没有及时释放</li><li>内存泄漏过多就会导致内存溢出</li></ul><p>常见的内存泄漏：</p><ul><li>意外的全局变量</li><li>没有及时清理的计时器或回调函数</li><li>不合理的使用闭包会导致内存泄漏</li></ul>',51),t=[o];function d(h,n){return l(),e("div",null,t)}const u=i(r,[["render",d],["__file","11_js_prototype.html.vue"]]);export{u as default};
