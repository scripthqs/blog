import{_ as e,o as l,c as o,f as d}from"./app-4d122d87.js";const i={},c=d('<h1 id="dom-操作" tabindex="-1"><a class="header-anchor" href="#dom-操作" aria-hidden="true">#</a> DOM 操作</h1><h2 id="dom-查询" tabindex="-1"><a class="header-anchor" href="#dom-查询" aria-hidden="true">#</a> DOM 查询</h2><ul><li><code>innerHTML</code> 这个属性可以获取到元素内部的 html 代码，对于自结束标签没有意义</li><li>如果需要读取元素节点属性：<code>元素.id</code> <code>元素.name</code> <code>元素.value</code></li><li>class 属性不能采用这种方式，读取 class 采用：<code>元素.className</code></li></ul><p>获取元素节点的子节点</p><ul><li><code>元素.getElementsByTagName(&#39;li&#39;);</code></li><li><code>子节点数组 = 父节点.childNodes;</code> 获取所有子节点。根据 DOM，标签中的空白和换行也会当成文本节点。</li><li><code>子节点数组 = 父节点.children;</code> 获取当前元素的所有子元素</li><li><code>.innerHTML</code>和<code>.innerText</code>的区别，innerText 没有标签，只有文本</li><li>在事件的响应函数中，响应函数是给谁绑定的，this 就是谁</li></ul><h2 id="获取-html-文档" tabindex="-1"><a class="header-anchor" href="#获取-html-文档" aria-hidden="true">#</a> 获取 html 文档</h2><ul><li><code>document.title</code> 获取文档标题</li><li><code>document.head</code> 获取文档的头标签</li><li><code>document.documentElement;</code>获取 html 根标签</li><li><code>document.body;</code>获取 body 标签</li><li><code>document.all;</code>获取页面中所有元素</li><li><code>var div = document.querySelector(&quot;.box1 div&quot;);</code>这个方法总会返回第一个元素，兼容 IE8 及以上</li><li><code>var div = document.querySelectorAll(&quot;.box1 div&quot;);</code>这个方法会返回符合条件的数组，兼容 IE8 及以上</li></ul><h2 id="dom-的增删改" tabindex="-1"><a class="header-anchor" href="#dom-的增删改" aria-hidden="true">#</a> DOM 的增删改</h2><ul><li><code>createElement()</code>创建元素节点</li><li><code>createTextNode()</code>创建文本节点</li><li><code>元素.innerHTML=&quot;新标签&quot;</code></li><li><code>appendChild()</code>把新的子节点添加到指定节点</li><li><code>父节点.insertBefore(前节点,后节点)</code>在指定的子节点前面插入新的子节点</li><li><code>父节点.replaceChild(新节点,旧节点)</code>在指定的子节点前面插入新的子节点</li><li><code>父节点.removeChild(新节点,旧节点)</code> 删除指定节点</li><li><code>需要删除的节点.parentNode.removeChild(需要删除的节点);</code></li><li>使用 innerHTML 也能完成 DOM 增删改的相关操作</li><li><code>父元素.innerHTML += &quot;&lt;li&gt;新标签&lt;/li&gt;&quot;;</code> 但是修改的内容较大</li><li>一般会将两种方法结合使用</li><li>在响应函数的末尾加<code>return false;</code>可以取消默认行为</li><li><code>confirm(&quot;确认删除吗?&quot;)</code>可以弹出确认取消框</li></ul><h2 id="dom-操作-css" tabindex="-1"><a class="header-anchor" href="#dom-操作-css" aria-hidden="true">#</a> DOM 操作 CSS</h2><p>通过 JS 修改元素的样式</p><ul><li>内联样式 <ul><li><code>元素.style.样式名 = &quot;样式值&quot;</code></li><li>如果 CSS 中的样式名中含有<code>-</code>，比如<code>background-color</code>，需要将这种样式名修改为驼峰命名法,<code>backgroundColor</code></li><li><code>border-top-width</code>修改为<code>borderTopWidth</code></li><li>通过这种方法设置的样式是内联样式，具有较高的优先级</li><li>通过<code>元素.style.样式名</code>可以读取内联样式的属性值</li><li><code>元素.style[&quot;属性&quot;];</code>这种方法读取更加灵活</li><li>这两种方法返回的属性值都是字符串，并且带单位</li></ul></li><li>元素当前显示的样式 <ul><li><code>元素.currentStyle.样式</code> 但是这种方法只有 IE 才能用</li><li><code>getComputedStyle()</code>这个方法 IE9 以上及其他浏览器可以使用，这是 window 的方法，可以直接使用，需要两个参数 <ul><li>需要获取的样式</li><li>可以传递一个伪元素，一般都传 null</li><li>该方法会返回一个对象，对象封装了当前元素对应的样式</li><li><code>getComputedStyle(box1,null).width</code></li><li>该方法或获取真实的值，而不是默认值，比如宽度，不会获取 auto，而是真实的像素值</li></ul></li></ul></li></ul>',12),t=[c];function a(r,n){return l(),o("div",null,t)}const h=e(i,[["render",a],["__file","18_js_DOM.html.vue"]]);export{h as default};
