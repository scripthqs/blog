import{_ as l,o as i,c as e,f as n}from"./app-f4e03468.js";const o={},r=n('<h1 id="数据类型" tabindex="-1"><a class="header-anchor" href="#数据类型" aria-hidden="true">#</a> 数据类型</h1><h2 id="js-数据类型" tabindex="-1"><a class="header-anchor" href="#js-数据类型" aria-hidden="true">#</a> js 数据类型</h2><p>截至到 2021 年，已经有 8 种数据类型。7 种原始数据类型（值类型），1 种引用数据类型（引用类型）。</p><ul><li><strong><code>String</code> 字符串</strong></li><li><strong><code>Number</code> 数值</strong></li><li><strong><code>Boolean</code> 布尔值</strong></li><li><strong><code>Null</code> 空值</strong></li><li><strong><code>Undefined</code> 未定义</strong></li><li><strong><code>Symbol</code> (ES6) 独一无二的值类型。</strong></li><li><strong><code>BigInt</code> (ES10) 大整数基本类型。</strong></li></ul><p>原始数据类型和引用数据类型两种类型的区别在于<strong>存储位置的不同</strong></p><ul><li>原始数据类型直接存储在栈（stack）中</li><li>引用数据类型存储在堆（heap）中的对象，引用数据类型在<strong>栈中存储了指针</strong>，该<strong>指针指向</strong>堆中该实体的<strong>起始地址</strong>。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</li></ul><h2 id="js-内存管理" tabindex="-1"><a class="header-anchor" href="#js-内存管理" aria-hidden="true">#</a> js 内存管理</h2><p>任何编程语言，在代码的执行过程中都是需要给它分配内存的。</p><ul><li>某些编程语言需要我们自己手动的管理内存(C 、C++)</li><li>某些编程语言会可以自动帮助我们管理内存(Java、Js、Python)</li></ul><p>内存的管理都会有如下的生命周期：</p><ol><li>申请，分配申请需要的内存</li><li>使用，使用分配的内存，存放一些东西，比如对象等</li><li>释放，不需要使用时，对其进行释放</li></ol><h2 id="堆和栈" tabindex="-1"><a class="header-anchor" href="#堆和栈" aria-hidden="true">#</a> 堆和栈</h2><p>堆和栈的概念存在于<strong>数据结构</strong>和<strong>操作系统内存</strong>中。</p><p>在数据结构中：</p><ul><li>在数据结构中，栈中数据的存取方式为先进后出。</li><li>堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。</li></ul><p>在操作系统中：</p><ul><li>内存被分为栈区和堆区</li><li>栈区内存由编译器自动分配释放，<strong>js 所有的变量都存在栈内存中</strong></li><li>堆区内存一般由开发者分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。</li></ul><h2 id="数据类型检测" tabindex="-1"><a class="header-anchor" href="#数据类型检测" aria-hidden="true">#</a> 数据类型检测</h2><ol><li><p>typeof</p><p>数组、对象、null 都会被判断为 object，其他判断都正确。</p></li><li><p>instanceof</p><ul><li>可以正确判断对象的类型，<strong>其内部运行机制是判断在其原型链中能否找到该类型的原型</strong>。</li><li><strong>只能正确判断引用数据类型</strong>，而不能判断基本数据类型。</li></ul></li><li><p>===</p><ul><li><code>===</code> 可以判断 undefined、null</li><li>数量类型判断不要使用<code>==</code>，因为它有可能会做数据类型转换。</li></ul></li><li><p>Object.prototype.toString.call()</p><ul><li>使用 Object 对象的原型方法 toString 来判断数据类型</li><li>这个方法很准确的判断各种类型</li></ul></li></ol><h2 id="undefined-与-null" tabindex="-1"><a class="header-anchor" href="#undefined-与-null" aria-hidden="true">#</a> undefined 与 null</h2><ul><li>undefined 代表变量没有赋值</li><li>null: 代表变量赋值了, 只是值为 null，表示<strong>空对象</strong></li></ul><p><strong>什么时候将变量赋值为 null</strong>?</p><ul><li>初始化赋值: 将要作为引用变量使用, 但对象还没有确定</li><li>结束时: 将变量指向的对象成为垃圾对象</li></ul><p>typeof null 返回一个对象</p><h2 id="js-变量类型" tabindex="-1"><a class="header-anchor" href="#js-变量类型" aria-hidden="true">#</a> js 变量类型</h2><p>js 的变量本身是没有类型的, 变量的类型实际上是变量内存中数据的类型 。</p><p><strong>变量类型</strong>:</p><ul><li>基本类型: 保存基本类型数据的变量</li><li>引用类型: 保存对象地址值的变量</li></ul>',28),t=[r];function s(a,d){return i(),e("div",null,t)}const u=l(o,[["render",s],["__file","03_type.html.vue"]]);export{u as default};
