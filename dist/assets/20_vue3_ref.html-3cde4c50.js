import{_ as e,o as a,c as s,f as n}from"./app-10c4e004.js";const i={},l=n(`<h1 id="vue-原理" tabindex="-1"><a class="header-anchor" href="#vue-原理" aria-hidden="true">#</a> vue 原理</h1><h2 id="vue2-和-vue3" tabindex="-1"><a class="header-anchor" href="#vue2-和-vue3" aria-hidden="true">#</a> vue2 和 vue3</h2><ol><li>defineProperty 该为 Proxy,解决数组无法通过下标修改，对象属性增减的问题</li><li>组合式 api 改为函数式编程，方便按需引入，配合 tree-shaking 打包体积变小</li><li>vue3 的 mixin 改为 hooks</li><li>v-model 监听的事件和传递值不一样 <ul><li>vue2 value，change</li><li>vue3 传递 modelValue，监听 update:modelValue</li></ul></li></ol><h2 id="ref-和-reactive" tabindex="-1"><a class="header-anchor" href="#ref-和-reactive" aria-hidden="true">#</a> ref 和 reactive</h2><p>ref:支持基本数据类型+引用数据类型 reactive:只支持引用数据类型</p><p>他们解构后都会丢失响应式，需要使用 toRefs。</p><p>ref 和 reactive 都可以定义对象、数组，具体使用哪个根据赋值方式来定</p><ul><li>直接赋值：ref 会保留响应式，reactive 会丢失响应式</li><li>修改数据：reactive 和 ref 都可以，但是 ref 需要多写个.value，vscode 可以提供插件自动补全 ref</li></ul><p>所以，官方推荐尽量都使用 ref</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token parameter">ref</span><span class="token operator">=&gt;</span> <span class="token keyword">new</span> <span class="token class-name">RefImpl</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>是引用类型<span class="token punctuation">)</span><span class="token punctuation">{</span>
  把对象包装成proxy对象，数组包装成类数组对象<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
把值作为<span class="token punctuation">.</span>value属性<span class="token punctuation">;</span>
利用es6的<span class="token keyword">class</span>，通过<span class="token keyword">get</span>和<span class="token keyword">set</span>给对象一个value属性<span class="token punctuation">;</span>
<span class="token parameter">ref本身的<span class="token keyword">set</span>在整体替换时会触发</span><span class="token operator">=&gt;</span>直接赋值
<span class="token parameter">修改属性时是触发Proxy的<span class="token keyword">get</span>和<span class="token keyword">set</span></span><span class="token operator">=&gt;</span>修改属性

<span class="token parameter">reactive</span><span class="token operator">=&gt;</span><span class="token keyword">new</span> <span class="token class-name">Proxy</span>
<span class="token keyword">return</span> 不是引用类型
设置Proxy的<span class="token keyword">get</span>和<span class="token keyword">set</span>
收集依赖
修改值，触发依赖更新
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="虚拟-dom" tabindex="-1"><a class="header-anchor" href="#虚拟-dom" aria-hidden="true">#</a> 虚拟 dom</h2><ol><li>vue 组件实例的<code>_vnode</code> 中可以看到这个属性</li><li>数据驱动，数据变化-&gt;页面用到相关数据的地方精准变化，最好知道是某个属性和内容</li><li>vue 能定位到变化的最小的颗粒度是组件，数据变化-&gt;组件变化</li><li>虚拟算法，用来比较两个虚拟 dom，找到变化点，更新真实 dom</li></ol><h2 id="diff-算法" tabindex="-1"><a class="header-anchor" href="#diff-算法" aria-hidden="true">#</a> diff 算法</h2><ul><li>同层比较和优化策略</li><li>三大核心操作：移动节点、更新节点、新增和删除节点</li><li>差异记录和批量更新</li></ul><p>v-for 的 key 作用</p><ul><li>key 属性是 dom 元素的唯一标识， 可以在 diff 算法用来判断是否是同一个节点</li><li>可以调高虚拟 dom 的更新效率：使用 index 做 key，破坏顺序操作的时候， 因为每一个节点都找不到对应的 key，导致部分节点不能复用,所有的新 vnode 都需要重新创建。</li><li>不设置 key 或者 key 不唯一可能会有 bug：结构中包含输入类的 DOM，会产生错误的 DOM 更新</li><li>数据没有逆序添加，逆序删除破坏顺序的操作， 只用于列表展示的话 使用 index 作为 Key 没有毛病</li></ul>`,16),r=[l];function t(o,d){return a(),s("div",null,r)}const p=e(i,[["render",t],["__file","20_vue3_ref.html.vue"]]);export{p as default};
