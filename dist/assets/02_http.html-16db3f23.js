import{_ as l,r as i,o,c as r,b as a,e,d as s,f as t}from"./app-10c4e004.js";const p="/assets/TCP_IP-824c0027.png",d="/assets/three_way-60d45ff8.png",c="/assets/HTTP-cdd9a0c3.png",h="/assets/status-c6be36b7.png",u={},T=t('<h1 id="http-基础" tabindex="-1"><a class="header-anchor" href="#http-基础" aria-hidden="true">#</a> HTTP 基础</h1><blockquote><p>问题：当在浏览器地址栏输入 url 时，web 页面是如何呈现的？</p></blockquote><p>HTTP 是超文本传输协议，web 页面使用 HTTP 协议作为规范，完成客户端（浏览器）和服务器端之间通信过程。通俗的讲：网页的资源通常都是放在 web 资源服务器中，由浏览器发送 HTTP 来获取、解析、展示的。</p><p>URL 的组成：</p><ul><li>协议://主机:端口/路径?查询</li><li>scheme://host:port/path?query#fragment</li></ul><p>HTTP 协议，超文本传输协议，详细规定了浏览器和万维网服务器之间相互通信的规则。协议就是约定，规定。</p><h2 id="ip-地址" tabindex="-1"><a class="header-anchor" href="#ip-地址" aria-hidden="true">#</a> ip 地址</h2><p><strong>ip 地址</strong>：ip 地址有 v4 和 v6 之分，IP 地址就是互联网上每台计算机/电子设备的唯一地址，因此 IP 地址具有唯一性。在开发期间，自己的电脑既是一台服务器，也是一个客户端，可以在本机浏览器中输入<strong>127.0.0.1</strong>进行访问。</p><h2 id="域名" tabindex="-1"><a class="header-anchor" href="#域名" aria-hidden="true">#</a> 域名</h2><p><strong>域名</strong>：尽管 IP 地址能够唯一地标记网络上的计算机，但 IP 地址是一长串数字，不直观，而且不便于记忆，于是人们又发明了另一套字符型的地址方案，叫<strong>域名地址</strong>。IP 地址和域名是一一对应的关系，这份对应关系存放在一种叫做<strong>域名服务器</strong>(<strong>DNS</strong>)的电脑中。在开发测试期间，<strong>127.0.0.1 对应的域名是 localhost</strong>。</p><blockquote><p>本地如果 localhost 无法使用，则是因为本机中的 hosts 文件中没有匹配上 ip 地址</p></blockquote><h2 id="网络协议" tabindex="-1"><a class="header-anchor" href="#网络协议" aria-hidden="true">#</a> 网络协议</h2><p><strong>网络协议</strong> ：网络上的计算机之间交换信息，就像我们说话用某种语言一样，在网络上的各台计算机之间也有一种语言，这就是网络协议，<strong>不同的计算机之间必须使用相同的网络协议才能进行通信</strong>。如：TCP、UDP、HTTP、FTP 等等。</p><h2 id="端口号" tabindex="-1"><a class="header-anchor" href="#端口号" aria-hidden="true">#</a> 端口号</h2><p><strong>端口号</strong>：服务器的端口号就像是现实生活中的门牌号一样。通过门牌号，外卖员就可以准确把外卖送到你的手中。同样的道理，在一台电脑中，可以运行 N 多个 web 服务。每个 web 服务都对应一个唯一的端口号（0-65535，2^16，常见的端口号别占用：20,21,22,25,80,443,3306,3389,11211,27017....）。客户端发送过来的网络请求，通过端口号，可以被准确地交给对应的 web 服务进行处理。0-65535</p><blockquote><p>注：服务器上的端口号是不可以重复的，必须是独一无二。<strong>http 服务默认端口号为 80，https 的端口号默认是 443。</strong></p></blockquote><h2 id="tcp-ip" tabindex="-1"><a class="header-anchor" href="#tcp-ip" aria-hidden="true">#</a> TCP/IP</h2><p>为了了解 HTTP，有必要先了解下 TCP/IP 协议族。我们使用的网络包括互联网，都是 TCP/IP 协议族的基础上运行的，HTTP 属于 TCP/IP 内部的子集。</p><p>计算机和网络设备通信，双方必须基于相同的方法，或者说规则，这种规则称为协议。这种协议的总称叫做 TCP/IP。</p><blockquote><p>也有说法 TCP/IP 是 TCP 和 IP 两种协议。</p></blockquote><h3 id="分层管理" tabindex="-1"><a class="header-anchor" href="#分层管理" aria-hidden="true">#</a> 分层管理</h3><p>TCP/IP 协议族采用分层管理：应用层、传输层、网络层、数据链路层。</p><ol><li>应用层：给用户提供服务。FTP 文件传输协议， DNS 域名系统，HTTP 协议属于该层。</li><li>传输层：提供两台计算机数据传输。有 TCP 和 UDP 两个协议。</li><li>网络层：通过哪种路径传输数据。IP 属于网络层。</li><li>链路层：处理连接网络的硬件部分。</li></ol><p><img src="'+p+'" alt="TCP/IP"></p><p>发送端从应用层往下走，接收端从应用层往上走。</p><h3 id="ip、tcp、dns" tabindex="-1"><a class="header-anchor" href="#ip、tcp、dns" aria-hidden="true">#</a> IP、TCP、DNS</h3><ol><li><p>IP 负责传输数据。IP 是协议，IP 地址是被分配的地址，IP 地址可变。</p></li><li><p>TCP 确保可靠性。TCP 协议采用三次握手策略。</p><p><img src="'+d+'" alt="三次握手"></p></li><li><p>DNS 负责域名解析。计算机一般有 IP 地址和域名，IP 地址是长纯数字不便记忆，所以我们一般使用域名。DNS 专门用来转换域名和 IP 地址。</p></li></ol><h3 id="页面加载的过程" tabindex="-1"><a class="header-anchor" href="#页面加载的过程" aria-hidden="true">#</a> 页面加载的过程</h3>',28),g=a("li",null,[e("浏览器查找域名对应的 IP 地址(DNS 查询：) "),a("ul",null,[a("li",null,"先判断是否有浏览器缓存->系统缓存->路由器缓存->ISP DNS 缓存->根域名服务器"),a("li",null,"在查看本地硬盘的 hosts 文件，有该域名规则直接使用 host 对应的 ip 地址")])],-1),m=a("li",null,[e("浏览器向 Web 服务器发送一个 HTTP 请求（TCP 三次握手） "),a("ul",null,[a("li",null,"浏览器->服务器端是否可以连接和接收数据"),a("li",null,"服务器->回答可以，反问浏览器"),a("li",null,"双方都同意")])],-1),P={href:"http://example.com",target:"_blank",rel:"noopener noreferrer"},b={href:"http://www.example.com",target:"_blank",rel:"noopener noreferrer"},k=a("li",null,"浏览器跟踪重定向地址，请求另一个带 www 的网址",-1),v=a("li",null,"服务器处理请求（通过路由读取资源）",-1),x=a("li",null,"服务器返回一个 HTTP 响应（报头中把 Content-type 设置为 'text/html'）",-1),_=a("li",null,"浏览器对 DOM 树构建",-1),f=a("li",null,"浏览器发送请求获取嵌在 HTML 中的资源（如图片、音频、视频、CSS、JS 等）",-1),C=a("li",null,"浏览器显示完成页面",-1),H=a("li",null,"浏览器发送异步请求",-1),j=t('<p>简而言之，输入网站域名，先获取到 index.html 文件，遇到 link 元素，下载 css 文件，遇到 script 元素下载 js 文件。</p><h2 id="http-请求" tabindex="-1"><a class="header-anchor" href="#http-请求" aria-hidden="true">#</a> HTTP 请求</h2><p>一次 HTTP 请求主要包括请求(Request)和响应(Response)</p><p><img src="'+c+`" alt="HTTP"></p><ol><li>前端应用从浏览器端向服务器发送 HTTP 请求(<strong>请求报文</strong>)</li><li>后台服务器接收到请求后, 调度服务器应用处理请求, 向浏览器端返回 HTTP 响应(<strong>响应报文</strong>)</li><li>浏览器端接收到响应, 解析显示响应体/调用监视回调</li></ol><h3 id="http-版本" tabindex="-1"><a class="header-anchor" href="#http-版本" aria-hidden="true">#</a> HTTP 版本</h3><ul><li>HTTP/0.9：发布于 1991 年，只支持 get 请求获取文本数据，当时主要是获取 HTML 页面的内容</li><li>HTTP/1.0：发布于 1996 年，支持 post、head 等请求方法，支持请求头、响应头，不局限文本数据，可以获取更多数据类型，但是浏览器的每次请求都需要与服务器建立一个 TCP 连接，请求处理完成后立即断开 TCP，每次建立连接增加了性能损耗。</li><li>HTTP/1.1：发布于 1997 年，目前使用最广泛的版本，增加了 put、delete 等请求方法，采用了持久连接，多个请求可以共用同一个 TCP 连接</li><li>HTTP/2.0：发布于 2015 年</li><li>HTTP/3.4：发布于 2018 年</li></ul><h3 id="http-请求方法" tabindex="-1"><a class="header-anchor" href="#http-请求方法" aria-hidden="true">#</a> HTTP 请求方法</h3><p>HTTP 有不同的请求方法，表示要对给定资源执行不同的操作。简单的可以理解为增删改查。</p><ol><li><code>GET</code>: 从服务器端<strong>读取</strong>数据（查）</li><li><code>POST</code>: 向服务器端<strong>添加</strong>新数据 （增）</li><li><code>PUT</code>: <strong>更新</strong>服务器端已经数据 （改）</li><li><code>DELETE</code>: <strong>删除</strong>服务器端数据 （删）</li><li><code>HEAD</code>：和 GET 请求类似，但是没有响应体。比如准备下载一个文件前，先获取文件的大小，再决定是否进行下载</li></ol><p>实际开发中，使用最后的是 get 和 post 请求，并且 post 请求也可以做增改删的功能。</p><h2 id="请求头" tabindex="-1"><a class="header-anchor" href="#请求头" aria-hidden="true">#</a> 请求头</h2><p>http 请求的 header 就是 http 的请求头，键值对组成，里面一些字段的作用：</p><ul><li><p>content-type：请求携带的数据类型</p><ul><li>application/x-www-form-urlencoded：表示数据被编码成以 &#39;&amp;&#39; 分隔的键 - 值对，同时以 &#39;=&#39; 分隔键和值</li><li>application/json：表示是一个 json 类型</li><li>application/json：表示是一个 json 类型</li><li>application/xml：表示是 xml 类型</li><li>multipart/form-data：表示是上传文件</li></ul></li><li><p>content-length：文件的大小长度</p></li><li><p>keep-alive：在 http1.1 中，所有连接默认是 connection: keep-alive 的</p></li><li><p>accept-encoding：告知服务器，客户端支持的文件压缩格式，比如 js 文件可以使用 gzip 编码，对应 .gz 文件</p></li><li><p>accept：告知服务器，客户端可接受文件的格式类型</p></li><li><p>user-agent：客户端相关的信息</p></li></ul><h3 id="请求行" tabindex="-1"><a class="header-anchor" href="#请求行" aria-hidden="true">#</a> 请求行</h3><ul><li>请求方法字段</li><li>URL 字段</li><li>HTTP 协议版本字段</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>method url
<span class="token constant">GET</span> <span class="token operator">/</span>product_detail<span class="token operator">?</span>id<span class="token operator">=</span><span class="token number">2</span>
<span class="token constant">POST</span> <span class="token operator">/</span>login
<span class="token constant">GET</span><span class="token operator">/</span>index<span class="token punctuation">.</span>html <span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="请求体" tabindex="-1"><a class="header-anchor" href="#请求体" aria-hidden="true">#</a> 请求体</h3><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>username<span class="token operator">=</span>tom<span class="token operator">&amp;</span>pwd<span class="token operator">=</span><span class="token number">123</span>
<span class="token punctuation">{</span><span class="token string-property property">&quot;username&quot;</span><span class="token operator">:</span> <span class="token string">&quot;tom&quot;</span><span class="token punctuation">,</span> <span class="token string-property property">&quot;pwd&quot;</span><span class="token operator">:</span> <span class="token number">123</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="请求报文" tabindex="-1"><a class="header-anchor" href="#请求报文" aria-hidden="true">#</a> 请求报文</h3><ul><li>行：GET/URL/HTTP1.1</li><li>头：Host:Cookie:Content-type:User-Agent：</li><li>空行:</li><li>体:get 请求为空，username=admin&amp;password=admin</li></ul><h2 id="http-响应报文" tabindex="-1"><a class="header-anchor" href="#http-响应报文" aria-hidden="true">#</a> HTTP 响应报文</h2><h3 id="响应状态行" tabindex="-1"><a class="header-anchor" href="#响应状态行" aria-hidden="true">#</a> 响应状态行</h3><p>由协议版本 状态码 状态码的原因短语组成</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>status statusText
<span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span> <span class="token number">200</span> <span class="token constant">OK</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="多个响应头" tabindex="-1"><a class="header-anchor" href="#多个响应头" aria-hidden="true">#</a> 多个响应头</h3><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>Content<span class="token operator">-</span>Type<span class="token operator">:</span> text<span class="token operator">/</span>html<span class="token punctuation">;</span>charset<span class="token operator">=</span>utf<span class="token operator">-</span><span class="token number">8</span>
Set<span class="token operator">-</span>Cookie<span class="token operator">:</span> <span class="token constant">BD_CK_SAM</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>path<span class="token operator">=</span><span class="token operator">/</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="响应体" tabindex="-1"><a class="header-anchor" href="#响应体" aria-hidden="true">#</a> 响应体</h3><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>html 文本<span class="token operator">/</span>json 文本<span class="token operator">/</span>js<span class="token operator">/</span>css<span class="token operator">/</span>图片<span class="token operator">...</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="响应报文" tabindex="-1"><a class="header-anchor" href="#响应报文" aria-hidden="true">#</a> 响应报文</h3><ul><li>行：HTTP/1.1 200（OK） 404（找不到） 403（被禁止）401（未授权）</li><li>头：content-type：content-length content-encoding</li><li>空行</li><li>体:HTML 的内容</li></ul><h2 id="post-请求体参数格式" tabindex="-1"><a class="header-anchor" href="#post-请求体参数格式" aria-hidden="true">#</a> post 请求体参数格式</h2><ol><li><code>Content-Type: application/x-www-form-urlencoded;charset=utf-8</code> 用于键值对参数，参数的键值用=连接, 参数之间用&amp;连接 例如: <code>name=%E5%B0%8F%E6%98%8E&amp;age=12</code></li><li><code>Content-Type: application/json;charset=utf-8</code> 用于 json 字符串参数 例如: <code>{&quot;name&quot;: &quot;%E5%B0%8F%E6%98%8E&quot;, &quot;age&quot;: 12}</code></li><li><code>Content-Type: multipart/form-data</code> 用于文件上传请求</li></ol><h2 id="常见的响应状态码" tabindex="-1"><a class="header-anchor" href="#常见的响应状态码" aria-hidden="true">#</a> 常见的响应状态码</h2><ul><li><code>200 OK</code> 请求成功。一般用于 GET 与 POST 请求</li><li><code>201 Created</code> 已创建。成功请求并创建了新的资源</li><li><code>301</code> 重定向</li><li><code>401 Unauthorized</code> 未授权/请求要求用户的身份认证</li><li><code>403</code> 没有权限访问</li><li><code>404 Not Found</code> 服务器无法根据客户端的请求找到资源</li><li><code>405</code> 请求方法不对</li><li><code>429</code> 请求过于频繁</li><li><code>500 Internal Server Error</code> 服务器内部错误，无法完成请求</li><li><code>503</code> 服务器没有运行</li></ul><p><img src="`+h+'" alt="响应状态码"></p><h2 id="api-的分类" tabindex="-1"><a class="header-anchor" href="#api-的分类" aria-hidden="true">#</a> API 的分类</h2><ol><li><p>REST API: restful （Representational State Transfer (资源)表现层状态转化）</p><ul><li>发送请求进行 CRUD 哪个操作由请求方式来决定</li><li>同一个请求路径可以进行多个操作</li><li>请求方式会用到 GET/POST/PUT/DELETE</li></ul></li><li><p>非 REST API: restless</p><ul><li>请求方式不决定请求的 CRUD 操作</li><li>一个请求路径只对应一个操作</li><li>一般只有 GET/POST</li></ul></li></ol><h2 id="区别一般-http-请求-与-ajax-请求" tabindex="-1"><a class="header-anchor" href="#区别一般-http-请求-与-ajax-请求" aria-hidden="true">#</a> 区别一般 http 请求 与 ajax 请求</h2><ol><li>ajax 请求是一种特别的 http 请求</li><li>对服务器端来说, 没有任何区别, 区别在<strong>浏览器端</strong></li><li>浏览器端发请求: 只有<code>XHR</code> 或<code>fetch</code> 发出的才是 ajax 请求, 其它所有的都是非 ajax 请求</li><li>浏览器端接收到响应 <ul><li>一般请求: 浏览器一般会直接显示响应体数据, 也就是我们常说的刷新/跳转页面</li><li>ajax 请求: 浏览器不会对界面进行任何更新操作, 只是<strong>调用监视的回调函数</strong>并<strong>传入响应相关数据</strong></li></ul></li></ol><h2 id="后端接口响应时间受到哪些因素影响" tabindex="-1"><a class="header-anchor" href="#后端接口响应时间受到哪些因素影响" aria-hidden="true">#</a> 后端接口响应时间受到哪些因素影响</h2><ol><li>前端网络状况：用户带宽延迟，丢包</li><li>服务器性能：硬件配置，并发处理能力</li><li>后端业务处理逻辑：接口内部的业务逻辑复杂度、数据库查询效率、第三方服务调用</li><li>数据库性能：数据库的查询速度、索引</li><li>接口排队与限流:高并发场景下，接口可能出现排队、限流、熔断等</li><li>CDN/缓存命中率: CDN 或缓存，命中率高则响应快</li><li>数据传输大小:响应体数据量大（如大图片、大文件、复杂 JSON），传输耗时增加</li><li>安全校验与中间件:鉴权、加解密、日志、网关等中间件处理也会增加响应时间</li></ol><h2 id="cdn" tabindex="-1"><a class="header-anchor" href="#cdn" aria-hidden="true">#</a> CDN</h2><p>CDN（Content Delivery Network）内容分发网络，能加速资源访问</p><ol><li>就近访问：全球/全国各地部署了大量节点（缓存服务器），用户访问资源时会自动连接到最近的节点，减少跨地域、跨国传输带来的延迟</li><li>缓存：态资源（如图片、JS、CSS、视频等）被缓存到各地 CDN 节点，大部分请求直接在 CDN 节点响应，减少源站服务器压力，提高整体并发能力</li><li>分布式：遇到单点故障时可自动切换到其他节点，保证资源高可用</li><li>智能调度：会根据用户的地理位置、网络状况、节点负载等，智能选择最快的节点响应请求</li></ol><h2 id="浏览器缓存" tabindex="-1"><a class="header-anchor" href="#浏览器缓存" aria-hidden="true">#</a> 浏览器缓存</h2><p>浏览器缓存是指浏览器会将已请求过的资源（如 HTML、CSS、JS、图片等）缓存在本地，下次访问相同资源时可以直接从本地读取，减少网络请求，加快页面加载速度，降低服务器压力。</p><p>强缓存（强制缓存）</p><ul><li>浏览器在请求资源时，<strong>直接使用本地缓存，不会向服务器发送请求</strong>。</li><li>由响应头 <code>Expires</code> 或 <code>Cache-Control</code> 控制。</li><li>只要缓存未过期，浏览器直接用本地资源，状态码为 200（from disk cache 或 memory cache）。</li></ul><p>协商缓存</p><ul><li>浏览器每次请求资源时，会带上缓存标识（如 ETag 或 Last-Modified）向服务器询问资源是否有更新。</li><li>如果资源未变，服务器返回 304 Not Modified，浏览器用本地缓存。</li><li>如果资源有变，服务器返回新资源和 200 状态码。</li></ul>',51);function I(S,E){const n=i("ExternalLinkIcon");return o(),r("div",null,[T,a("ol",null,[g,m,a("li",null,[e("服务器 301 重定向（从 "),a("a",P,[e("http://example.com"),s(n)]),e(" 重定向到 "),a("a",b,[e("http://www.example.com"),s(n)]),e("）")]),k,v,x,_,f,C,H]),j])}const D=l(u,[["render",I],["__file","02_http.html.vue"]]);export{D as default};
