import{_ as e,o as i,c as r,f as a}from"./app-10c4e004.js";const l={},t=a('<h1 id="react-深度解析" tabindex="-1"><a class="header-anchor" href="#react-深度解析" aria-hidden="true">#</a> react 深度解析</h1><h2 id="虚拟-dom" tabindex="-1"><a class="header-anchor" href="#虚拟-dom" aria-hidden="true">#</a> 虚拟 DOM</h2><p>Virtual DOM 就是用 JavaScript 对象去描述一个 DOM 结构，虚拟 DOM 不是直接操作浏览器的真实 DOM,而是首先对 UI 的更新在虚拟 DOM 中进行，再将变更高效地同步到真实 DOM 中</p><p>优点</p><ol><li>性能优化:直接操作真实 DOM 是比较昂贵的，尤其是当涉及到大量节点更新时。虚拟 DOM 通过减少不必要的 DOM 操作，主要体现在 diff 算法的复用操作，其实也提升不了多少性能。</li><li>跨平台性:虚拟 DOM 是一个与平台无关的概念，它可以映射到不同的渲染目标，比如浏览器的 DOM 或者移动端(React Native)的原生 UI</li></ol><h2 id="fiber-的作用" tabindex="-1"><a class="header-anchor" href="#fiber-的作用" aria-hidden="true">#</a> Fiber 的作用</h2><p>为了解决 React15 在大组件更新时产生的卡顿现象，React 团队提出了 Fiber 架构，并在 React16 发布，将 同步递归无法中断的更新 重构为 异步的可中断更新</p><p>它实现了 4 个具体目标</p><ol><li>可中断的渲染:Fiber 允许将大的渲染任务拆分成多个小的工作单元（Unit of Work），使得 React 可以在空闲时间执行这些小任务。当浏览器需要处理更高优先级的任务时(如用户输入、动画)，可以暂停渲染，先处理这些任务，然后再恢复未完成的渲染工作。</li><li>优先级调度:在 Fiber 架构下，React 可以根据不同任务的优先级决定何时更新哪些部分。React 会优先更新用户可感知的部分(如动画、用户输入)，而低优先级的任务(如数据加载后的界面更新)可以延后执行。</li><li>双缓存树(Fiber Tree): Fiber 架构中有两棵 Fiber 树--current fiber tree(当前正在渲染的 Fiber 树)和 work in progress fiber tree(正在处理的 Fiber 树)。React 使用这两棵树来保存更新前后的状态，从而更高效地进行比较和更新。(类似 vue 新旧 dom 对比)</li><li>任务切片:在浏览器的空闲时间内(利用 requestIdleCallback 思想)，React 可以将渲染任务拆分成多个小片段，逐步完成 Fiber 树的构建，避免一次性完成所有演染任务导致的阻塞。</li></ol><p>任务切片：浏览器网页动画达到 60FPS(换算下来每一帧 16.6ms),就会觉得流畅,浏览器需要花费一些时间将内容绘制到屏幕上，所以通常只有 10 毫秒来执行 js 代码</p><p>浏览器每帧要干嘛：</p><ol><li>处理事件的回调 click</li><li>处理计时器的回调</li><li>开始帧</li><li>执行 requestAnimationFrame 动画</li><li>计算机页面布局计算 合并到主线程</li><li>绘制</li><li>有空闲时间执行 requestIdleCallback</li></ol>',12),c=[t];function o(d,n){return i(),r("div",null,c)}const h=e(l,[["render",o],["__file","22_react.html.vue"]]);export{h as default};
