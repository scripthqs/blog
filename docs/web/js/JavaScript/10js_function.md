# 函数基础

函数（Function）：特殊的对象，可以执行。

## 函数的概念

- 实现特定功能的多条语句的封装体
- 只有函数是可以执行的
- 函数也是对象
- 函数中可以封装一些功能（代码），在需要时可以只写这些功能和代码
- 可以将要封装的的代码以**字符串的形式**传递给构造函数
- 封装的代码不会立即执行
- 函数代码会在函数调用的时候执行，
- 所有的函数，都是 Function 的“实例”（或者说是“实例对象”）。函数本质上都是通过 new Function 得到的。
- 函数既然是实例对象，那么，函数也属于“对象”。

## 创建函数对象

1. 以构造函数的方式创建函数：

   - `var fun = new Function();`
   - 实际开发中，不会使用这种方式

2. 使用函数声明来创建函数：

   ```js
    function 函数名([形参1,形参2...形参N]){
      语句...
    }
   ```

   ```js
   function fun1(a, b) {
     return a + b;
   }
   ```

   - 备注：语法中的中括号，表示“可选”

3. 函数表达式（匿名函数）

   ```js
    var 变量名  = function([形参1,形参2...形参N]){
      语句....
    }
   ```

   ```js
   var fun2 = function() {
     console.log("我是匿名函数中封装的代码");
   };
   ```

## 函数的调用

- 普通函数的调用，语法：`函数();`或者`函数名.call();`。

```js
fun();
```

- 通过对象的方法来调用，如果一个函数是作为一个对象的属性保存，那么，我们称这个函数是这个对象的方法。

```js
obj.fun();
```

- 立即执行函数

```js
(function() {
  console.log("匿名函数");
})();
```

- 通过构造函数来调用

```js
new fun();
```

- 临时将一个函数作为指定对象的方法调用

```js
fun.call / apply(obj);
```

apply 与 call 的唯一**区别**就是：**调用 apply 方法时的参数，实参应该是以数组的形式来书写**。

- 绑定事件函数
- 定时器函数

```js
let num = 1;
setInterval(function() {
  num++;
  console.log(num);
}, 1000);
```

## 形参和实参

形参：

- 形式上的参数。定义函数时传递的参数，当时并不知道是什么值。
- 定义函数时，可以在函数的()中来指定一个或多个形参。
- 多个形参之间使用,隔开，声明形参就相当于在函数内部声明了对应的变量，但是并不赋值。

实参：

- 概念：实际上的参数。调用函数时传递的参数，实参将会传递给函数中对应的形参。
- 在调用函数时，可以在函数的 ()中指定实参。
- 实际参数和形式参数的个数，一般要相同。
- 如果实参的数量少于形参的数量，多余的形参会被定义为 `undefined`
- 如果实参的数量多余形参的数量，多余实参不会被赋值。
- 实参可以是任意数据类型，当需要传递的实参过多时，可以封装到对象中传递。

在 JS 中，形参的默认值是 `undefined`。

## 函数的返回值

- 可以使用 return 来设置函数的返回值，语法：`return 值;`
- `return`后的值将作为函数的执行结果返回
- 定义一个变量来接收该结果
- 在函数中，`return`后的语句都不再执行
- 如果函数中不写 return 或者 return 后面不写值，都返回`undefined`
- 返回值可以是任意的数据类型
- `return` 只能返回一个值。如果用逗号隔开多个值，则以最后一个为准
- fn 代表的是整个函数，而 fn()代表的是返回值。

## 作用域

作用域指一个变量作用的范围，在 JS 中有两种作用域：

- 全局作用域

  - 直接编写到 script 标签中的 JS 代码，都在全局作用域
  - 全局作用域在页面打开时创建，关闭时销毁
  - 在全局作用域中有一个全局对象 window，代表浏览器的窗口，由浏览器创建，我们可以直接使用
  - 在全局作用域中，我们创建的变量都会作为 window 对象的属性保存
  - 创建的函数会作为 window 对象的方法保存
  - 全局作用域中的变量都是全局变量，在页面的任意部分都可以访问

- 函数作用域
  - 调用函数时创建函数作用域，函数执行完毕后，函数作用域销毁
  - 每调用一次函数就会创建一个新的作用域，他们是相互独立的
  - 在函数作用域中可以访问到全局作用域的变量
  - 全局作用域无法访问到函数作用域的变量
  - 当在函数作用域中操作变量时，会先在自身作用域中寻找，有就直接使用，没有则向上一级作用域寻找。直到全局作用域，没找到就报错
  - 在函数中访问全局的变量可以使用 window 对象
  - 在函数作用域中也有声明提前，使用 var 和 function 都会声明提前
  - 在函数作用域中不使用 var 声明的变量都会称为全局变量
  - 定义形参相当于在函数作用域中声明了变量

## 变量的声明提前

使用 var 关键字声明的变量，会在所有的代码执行前被声明（但是不会被赋值）。但是如果声明变量时不使用 var 关键字，变量不会声明提前。

函数的声明提前

- 使用函数声明创建的函数`function fun(){}`，会在所有的代码执行之前就被创建，我们可以在函数声明前调用函数。
- 使用函数表达式创建的函数`var fun = function(){}`不会声明提前

## this

解析器（浏览器）在调用函数时，每次都会向函数内部传递进一个隐含的参数，这个隐含的的参数就是 this。

- this 指向一个对象，这个对象我们称为函数的执行上下文对象
- 根据函数的调用的方式不同，this 会指向不同的对象
- 以函数的形式调用时，this 永远都是 window
- 以方法的形式调用时，this 就是调用这个方法的对象
- 以构造函数的形式调用时，this 就是实例，即`var per = new Penson();`的`per`
- 以 call()和 apply()调用时，this 是指定的那个对象，即`fun.call(obj1)和fun.apply(obj2);`中的 obj1 和 obj2
- 在事件的响应函数中，响应函数是给谁绑定的，this 就是谁，即`btn.onclick = function () {console.log(this);}`，此时，this 是 btn

## arguments

调用函数时的隐含参数除了 this 还有 arguments

- arguments 是封装实参的对象
- 是一个类数组对象，它也可以通过索引操作数据，获取长度
- 在调用函数时，我们所传递的实参都会在 arguments 中保存
- arguments.length 可以获取实参的长度
- 我们即使不定义形参，也可以通过 arguments 来使用实参
- `arguments[0]、arguments[1]`分别表示第一个，第二个实参
- `arguments.callee`这个属性对应一个函数对象，就是当前正在指向的函数的对象
- `arguments.callee ===fun // true`

## 工厂模式创建对象

使用工厂方法创建对象，通过该方法可以大批量创建对象.

- 创建一个函数
- 函数里创建一个新的对象
- 对象里添加属性
- 将新的对象通过 return 作为函数值返回
- 从外面传递参数

这种方法使用的构造函数都是 Object，所以创建的对象都是 Object 这个类型，就导致我们无法区分多种不同类型的对象。

## 构造函数创建对象

- 创建一个构造函数，专门创建 Person 对象（Penson 类）
- 构造函数就是一个普通的函数，创建方式和普通函数没什么区别
- 不同的是构造函数习惯首字母大写
- 构造函数和普通函数的区别就是调用的方式不同
- 普通函数直接调用，构造函数需要使用 new 关键字调用`var per = new Penson;`
- 使用同一类构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类（Person 类），创建的对象称为该类的实例，或者该构造函数的实例。`per是Person类的实例`

构造函数的执行流程：

- 立即创建一个新的对象
- 将新建的对象设置为函数的 this，在构造函数中可以使用 this 来引用新建的对象
- 逐行执行函数中的代码
- 将新建的对象作为返回值返回

通过 instanceof 可以检查一个对象是否是一个类的实例

- `对象 instanceof 构造函数`
- 是则返回 true，不是则返回 false

所有的对象都是 Object 构造函数的实例

将函数定义在全局作用域中，会污染全局作用域的命名空间，也很不安全。

JavaScript 的构造函数中可以添加一些成员，可以在构造函数本身上添加，也可以在构造函数内部的 this 上添加。通过这两种方式添加的成员，就分别称为静态成员和实例成员。

- 静态成员：在构造函数本上添加的成员称为静态成员，只能由构造函数本身来访问。
- 实例成员：在构造函数内部创建的对象成员称为实例成员，只能由实例化的对象来访问。

## 高阶函数

当函数 A 接收函数 B 作为参数，或者把函数 C 作为返回值输出时，我们称函数 A 为高阶函数。高阶函数是对其他函数进行操作的函数。

- 把其他函数作为参数

```js
function fn1(a, b, f) {
  console.log(a + b);
  f && f();
}
fn1(10, 20, function() {
  console.log("我是一个函数");
});
```

- 把其他函数作为返回值

```js
function fn1() {
  let a = 20;
  return function() {
    console.log(a);
  };
}
const foo = fn1();
foo();
```

变量 a 是函数内的局部变量，所以外部无法访问。

## 闭包

- 有权访问另一个函数作用域中变量的函数称为闭包。
- 闭包是一种函数，闭包是一种现象。
- 这个作用域可以访问另一个函数内部的局部变量，就产生了闭包（这时理解为一种现象），另外那个作用域所在的函数称之为闭包函数。
- 强调的是访问局部变量

```js
function fn1() {
  let a = 10;

  function fn2() {
    console.log(a); //在 chrome 浏览器控制台中，设置断点，可以调试闭包Closure
  }
  fn2();
}

fn1();
```

- 函数 fn2 的作用域访问了 fn1 中的局部变量，此时，fn1 中就产生了闭包，fn1 称之为闭包函数。
- 一般来说，在 fn1 函数执行完毕后，它里面的变量 a 会立即销毁
- 由于产生了闭包，所以 fn1 函数中的变量 a 不会立即销毁，因为 fn2 函数还要继续调用变量 a
- 只有等所有函数把变量 a 调用完了，变量 a 才会销毁。
- 闭包的主要作用就是：延伸了变量的作用范围。
