# 浏览器的事件循环(event loop)

**浏览器事件循环是浏览器处理各种任务的机制。**

浏览器在运行过程中，会同时面对很多任务，用户的各种交互事件，网络请求，页面渲染等。这些任务并不是无序的，浏览器内部需要处理这些任务，所以就出现了事件循环。

## 进程和线程

程序需要有自己的内存空间，这个内存空间简单的理解为进程。

- 每个程序至少一个进程
- 一个进程至少一个线程，进程开启后会自动创建一个线程，该线程叫主线程

浏览器是一个多进程多线程应用程序。浏览器更多工具任务管理器可以看到进程，其中最主要的进程：

- 浏览器进程：负责页面显示，用户交互，子进程管理
- 网络进程：负责加载网络资源
- 渲染进程：渲染进程启动后，会开启一个渲染主线程，主要负责执行 HTML、CSS、JS 代码

## 渲染主线程

渲染主线程是浏览器最繁忙的线程，主要处理的任务包括：

- 解析 HTML
- 解析 CSS
- 计算样式
- 处理图层
- 每秒把页面执行 60 次
- 执行全局 JS 代码
- 执行事件处理函数
- 执行计时器的回调函数
- ...

主线程需要处理非常多的任务，需要合理的调度任务：

- 正在执行 js 函数，执行到一半用户点击了按钮，需要立即执行吗？
- 正在执行 js 函数，执行到一半某个计时器达到了时间，需要立即去执行吗？
- 用户点按钮的同时，某个计时器也到达了时间，该处理哪一个？

所以，浏览器需要排队

1. 开始时渲染主线程，会进入一个无限循环
2. 每一个循环会检查消息队列是否有任务存在，如果有，取出第一个执行，没有则休眠
3. 其他所有线程，可以随时向消息队列中添加任务，新任务在消息末尾。如果此时主线程时休眠的，则唤醒继续循环去任务
4. 整个过程，称为事件循环(消息循环)

```js
渲染主线程：正在执行的任务...
消息队列:任务1 任务2 任务3...
message queue
```

## 异步

代码在执行是，会遇到无法立即处理的任务

- 计时器完成后需要执行的任务 setTimeout、setInterval
- 网络通信完成后需要执行的任务 XHR、Fetch
- 用户操作后需要执行的任务 addEventListener

如果让渲染主线程等这些任务执行，会导致浏览器长期处于阻塞状态，会导致浏览器卡死。浏览器的解决方案就是使用异步。

主线程遇到定时器时，定时器会进入定时器线程，计时完后，进入消息队列，浏览器的渲染引擎只管按照消息队列的顺序执行，渲染主线程永不阻塞。

- 异步的出现是因为浏览器的渲染引擎是单线程。
- 异步是通过事件循环实现的

### js 的异步

1. js 是一门单线程的语言，因为 js 运行在浏览器的渲染主线程中，而渲染主线程只有一个。
2. 渲染主线程负责渲染页面，执行 js 等。如果使用同步的方式极可能导致主线程产生阻塞，从而消息队列中的任务无法执行。这样既会浪费主线程的时间，又导致页面无法及时更新。
3. 浏览器采用异步的方式来避免这种情况，当定时器、网络请求、事件监听等任务发生时、主线程会将这些任务交给其他线程去处理，自身立即结束该类任务，转而继续去执行后续代码。当其他线程完成后，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。在这种异步模式下，浏览器永不阻塞，从而最大限度的保证单线程的流畅执行。

### 宏任务和微任务

宏任务

- 整体代码（script 脚本）
- 定时器 setTimeout、setInterval
- I/O 操作（如文件、网络请求的回调）
- UI 渲染、事件回调（如 click、load 等）

微任务

- Promise 的 then/catch/finally 回调
- MutationObserver 回调
- vue 的$nextTick，内部使用 Promise 和 MutationObserver 实现

### 任务的优先级

任务是没有优先级的，在消息队列中先进先出。但消息队列是有优先级的。

> 以前的说法是宏队列(普通队列)加微队列(VIP 队列)，但是随着浏览器复杂度急剧提升，W3C 不再使用宏队列的说法。两个队列不好搞定。

- 每个任务都有一个任务类型，同一个类型的任务必须在同一个队列里，浏览器可以根据实际的情况从不同的队列中取出任务执行
- 浏览器必须准备一个微队列，微队列中的任务优先所有其他任务执行

chrome 的实现中，至少有以下队列：

- 延时队列：优先级中
- 交互队列：优先级高
- 微队列：优先级最高

添加任务到微队列的主要方式是：使用 Promise、MutationObserver

## js 事件循环

- 事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。
- chrome 会开启一个不会结束的 for 循环，每次循环都从消息队列中取出第一个任务执行，其他线程只需要在消息队列后面排队。
- 之前的消息队列分为宏队列和微队列，现在是每一任务都有不同的类型，同一个类型的任务必须在同一个队列，不同队列优先级不同。浏览器自己决定执行哪个队列，但是都会有一个微队列，它具有最高优先级，必须优先调度执行。

## js 的计时器能否准确计时

不能

1. js 计时器调用的是操作系统的函数，不同操作系统肯定存在偏差
2. 浏览器计时时，如果嵌套过多，超过了 5 层，会带至少 4ms 的偏差
3. 受事件循环的影响，计时器回调函数只能在主线程空闲时运行，所有会有偏差
